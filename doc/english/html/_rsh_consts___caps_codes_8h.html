<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Rsh API: G:/SDK2/HEADERS/Include/RshConsts_CapsCodes.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rsh.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rsh API
   &#160;<span id="projectnumber">SDK 2.1</span>
   </div>
   <div id="projectbrief">Programming manual</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="page__examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2eb228eaf9aee299c66d8fb3a868065e.html">HEADERS</a></li><li class="navelem"><a class="el" href="dir_247cc5d6a0059d721fe6b5dcc5a7b566.html">Include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">RshConsts_CapsCodes.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CAPS codes constants enum for Rsh SDK.  
<a href="#details">More...</a></p>
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_rsh_consts___caps_codes_8h__dep__incl.png" border="0" usemap="#_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep" alt=""/></div>
<map name="_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep" id="_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep">
<area shape="rect" id="node2" href="_rsh_consts_8h.html" title="This file includes all RSH SDK constant headers. " alt="" coords="5,99,219,143"/><area shape="rect" id="node5" href="_rsh_caps_description_8h.html" title="Simple structure to hold CAPS related data. " alt="" coords="243,99,457,143"/><area shape="rect" id="node3" href="_rsh_api_8h.html" title="The main RSH API include file. " alt="" coords="5,193,219,237"/><area shape="rect" id="node4" href="_rsh_api_8cpp.html" title="Rsh Api internal class and template implementation. " alt="" coords="5,286,219,330"/></map>
</div>
</div>
<p><a href="_rsh_consts___caps_codes_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a7d002d179754641063bf0db5344f5866"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">RSH_CAPS</a> { <br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a0cdac3b59f68c304f552fcf2a5e2cddb">RSH_CAPS_DEVICE_PCI</a> = 0, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a142967aefc516c7ca805802a355137bf">RSH_CAPS_DEVICE_PCI_EXPRESS</a> = 1, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abcb2ae69029c641240b6b1b18bc680da">RSH_CAPS_DEVICE_USB1_1</a> = 2, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866add7224aea95d9a4a555e57b98be050c1">RSH_CAPS_DEVICE_USB2_0</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9f88b48187f74e19cc49cf4598fac023">RSH_CAPS_DEVICE_USB3_0</a> = 4, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac8d5c7767649c7be6aeae9589fc8e3a7">RSH_CAPS_DEVICE_ETHERNET</a> = 5, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1b10048c646f00eb3145b59ca496581b">RSH_CAPS_DEVICE_FREQUENCY_SYNTHESIZER</a> = 15, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df">RSH_CAPS_DEVICE_TIMER_8254</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ab87bba0f65de1d3698ef563de17187ba">RSH_CAPS_DEVICE_MEMORY_PER_CHANNEL</a> = 17, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6">RSH_CAPS_DEVICE_FREQUENCY_LIST</a> = 18, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a18a96c881cf6b541c631809b03034e37">RSH_CAPS_DEVICE_SIZE_LIST</a> = 19, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9b7f3987af00b135e1b3c6db726ffc09">RSH_CAPS_DEVICE_HAS_DIGITAL_PORT</a> = 20, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7fa1a1277d1d227fb8a7384a35ed7773">RSH_CAPS_DEVICE_GAIN_LIST</a> = 21, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac13ebe592ce8056360f9b390a8a28c83">RSH_CAPS_DEVICE_GAINS_PER_CHANNEL</a> = 22, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b">RSH_CAPS_DEVICE_PREHISTORY</a> = 23, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> = 24, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a29b7d124678551cd2ce885ce2857f12d">RSH_CAPS_DEVICE_QUADRO_FREQUENCY_MODE</a> = 25, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba">RSH_CAPS_DEVICE_AUTO_CALIBRATION</a> = 26, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1d7c7830ca32b68ec713eaf7196502b6">RSH_CAPS_DEVICE_SYNCHRO_INTERNAL</a> = 27, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4e931de0e0a4fb97becc7c552239d2fd">RSH_CAPS_DEVICE_SYNCHRO_EXTERNAL</a> = 28, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a819d7c0f4299baf67e2c592b78340105">RSH_CAPS_DEVICE_EXTERNAL_START</a> = 29, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a842258001468451ee1fd6850b26e1581">RSH_CAPS_DEVICE_HYSTERESIS</a> = 30, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a211335ed1c186623a20bbdd34ee5fb36">RSH_CAPS_DEVICE_EXT_SYNC_GAIN_LIST</a> = 31, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a42cb2fa30a80c290cf5c912a66001285">RSH_CAPS_DEVICE_EXT_SYNC_FILTER_LOW</a> = 32, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6139d67568b35cfc2a7adde139fc1ec5">RSH_CAPS_DEVICE_EXT_SYNC_FILTER_HIGH</a> = 33, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ae08ef0174287786460f481831ccea3a8">RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM</a> = 34, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7ac24ea80e3d47378983f78763e13318">RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM</a> = 35, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> = 36, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a002451fcec1e06a5a45ef19cefc94a96">RSH_CAPS_DEVICE_HAS_DAC_INSTALLED</a> = 37, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abf6f85bf5eab39826a654553549b2316">RSH_CAPS_DEVICE_INPUT_LEVEL_ADJUSTMENT</a> = 38, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> = 39, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8ef713b84c323d70257b352ec1370075">RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM</a> = 40, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a06104c4dec442b75afaa51ed1f5dbdde">RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM</a> = 41, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866afe2bb60b36d6727f6c772154b53487c0">RSH_CAPS_DEVICE_FRAME_FREQUENCY_MODE</a> = 43, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9b0777dfe1f4aae1634e1b93227005d0">RSH_CAPS_DEVICE_PACKET_MODE</a> = 44, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a72bc3e5be326765db46df01f989d8901">RSH_CAPS_DEVICE_START_DELAY</a> = 45, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aab020fd08c44e6af6b9ff1ca657e59f5">RSH_CAPS_DEVICE_SLAVE_MASTER_SWITCH</a> = 46, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ae0218b6df2f5e3cef65793b25a48389a">RSH_CAPS_DEVICE_SYNCHRO_CHANNELS</a> = 47, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9f291ff9cb8c78e6cc63fe9dd7732001">RSH_CAPS_DEVICE_EXTERNAL_FREQUENCY</a> = 48, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abbd6a3d6733d7e318c076e5dc28c23f1">RSH_CAPS_DEVICE_FREQUENCY_SWITCH_PREHISTORY</a> = 49, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a> = 50, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1ea35492c22a13ec7ed1d04bb46b19b1">RSH_CAPS_DEVICE_DIFFERENTIAL_INPUT_MODE</a> = 51, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a729f46ef82a336136a8d9c2b2ff4864c">RSH_CAPS_DEVICE_FLASH_INFO_ONBOARD</a> = 52, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866adc0c2c58e598217f009c8da5d6a32355">RSH_CAPS_DEVICE_GPS_MODULE_INSTALLED</a> = 53, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4a5a6e1eaea445c32aa1e7b859f79547">RSH_CAPS_DEVICE_AUTO_START_MODE</a> = 54, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac2dd322d1bd59b2cfd167b88f55baff0">RSH_CAPS_DEVICE_DIGITAL_PORT_DATA_WITH_ANALOG_DATA</a> = 55, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> = 512, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aefaad7f3baecfb66eeff2f68be7e0a9d">RSH_CAPS_SOFT_GATHERING_IS_AVAILABLE</a> = 513, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866acfd92070f34276c75c9cef5f486fb246">RSH_CAPS_SOFT_PGATHERING_IS_AVAILABLE</a> = 514, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ad726d65aed23416c15896fde9429c91e">RSH_CAPS_SOFT_DIGITAL_PORT_IS_AVAILABLE</a> = 515, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a32c747c421e618cb1140269dace49079">RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE</a> = 516, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a5ed5faedf3212a6c617025124db414ce">RSH_CAPS_SOFT_INIT_MEMORY</a> = 517, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6b5450990b92306f3c288cd8325be52c">RSH_CAPS_SOFT_INIT_DMA</a> = 518, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866adefc92cd8599903fa80aa6a5b100b837">RSH_CAPS_SOFT_INIT_GSPF</a> = 519, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a91e93fec1d767db707c24a2d9893d634">RSH_CAPS_SOFT_INIT_VOLTMETER</a> = 520, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aa3e2fe9f73f6764cf89f870e782a1d74">RSH_CAPS_SOFT_INIT_TIMER</a> = 521, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a12ec3905812e467bfcb3be66da310ec8">RSH_CAPS_SOFT_STROBOSCOPE</a> = 522, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b">RSH_CAPS_SOFT_INIT_DAC</a> = 523, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a64b485141c3711ba52383ba4990f3620">RSH_CAPS_SOFT_INIT_PORT</a> = 524, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4013f7fb7ad5fa0e49b5b1a950daec30">RSH_CAPS_SOFT_TUNER_MODE_IS_AVAILABLE</a> = 525, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a74a0c31f5093f34767ed96ba1f48c0b7">RSH_CAPS_MAX</a> = 1024
<br/>
 }</td></tr>
<tr class="memdesc:a7d002d179754641063bf0db5344f5866"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of device and software capabilities (features).  <a href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">More...</a><br/></td></tr>
<tr class="separator:a7d002d179754641063bf0db5344f5866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CAPS codes constants enum for Rsh SDK. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>JSC "Rudnev-Shilyaev"</dd></dl>
<dl class="section date"><dt>Date</dt><dd>10.12.2015 </dd></dl>
<dl class="section version"><dt>Version</dt><dd>1.0 [SDK 2.1] </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a7d002d179754641063bf0db5344f5866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">RSH_CAPS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>List of device and software capabilities (features). </p>
<p>You can check what device is capable of using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameter <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ac5d41944239efbcfa7b5b9e1d65e9aa9" title="Check for device and software feature support. ">RSH_GET_DEVICE_IS_CAPABLE</a>.<br/>
</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> | <a class="el" href="_i_rsh_device__get__r_s_h__g_e_t__d_e_v_i_c_e__i_s__c_a_p_a_b_l_e__e_n_8cpp-example.html">Usage example </a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a0cdac3b59f68c304f552fcf2a5e2cddb"></a>RSH_CAPS_DEVICE_PCI</em>&nbsp;</td><td class="fielddoc">
<p>Device has PCI interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a142967aefc516c7ca805802a355137bf"></a>RSH_CAPS_DEVICE_PCI_EXPRESS</em>&nbsp;</td><td class="fielddoc">
<p>Device has PCI Express interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abcb2ae69029c641240b6b1b18bc680da"></a>RSH_CAPS_DEVICE_USB1_1</em>&nbsp;</td><td class="fielddoc">
<p>Device has USB 1.1 interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866add7224aea95d9a4a555e57b98be050c1"></a>RSH_CAPS_DEVICE_USB2_0</em>&nbsp;</td><td class="fielddoc">
<p>Device has USB 2.0 interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9f88b48187f74e19cc49cf4598fac023"></a>RSH_CAPS_DEVICE_USB3_0</em>&nbsp;</td><td class="fielddoc">
<p>Device has USB 3.0 interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac8d5c7767649c7be6aeae9589fc8e3a7"></a>RSH_CAPS_DEVICE_ETHERNET</em>&nbsp;</td><td class="fielddoc">
<p>Device has Ethernet interface. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1b10048c646f00eb3145b59ca496581b"></a>RSH_CAPS_DEVICE_FREQUENCY_SYNTHESIZER</em>&nbsp;</td><td class="fielddoc">
<p>Device has frequency synthesizer installed. </p>
<p>Frequency synthesizer allows to vary sampling rate smoothly, opposite to standart devices with frequency divider, where you have maximum frequency Fmax and dirived frequencies such as Fmax/2, Fmax/4 etc.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Some devices with frequency synthesizer DO NOT SUPPORT free frequency select and have a list of the predefined frequencies anyway. Check it using <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6" title="Device has predefined sampling rates list. ">RSH_CAPS_DEVICE_FREQUENCY_LIST</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6" title="Device has predefined sampling rates list. ">RSH_CAPS_DEVICE_FREQUENCY_LIST</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a519cd84aa5fa0a7d7f012f5992fb47bd" title="Device frequency list. ">RSH_GET_DEVICE_FREQUENCY_LIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df"></a>RSH_CAPS_DEVICE_TIMER_8254</em>&nbsp;</td><td class="fielddoc">
<p>Device has 3 channel Intel 8254 PIT chip installed. </p>
<p>Using <a class="el" href="struct_rsh_init_timer.html" title="Direct timers control structure. ">RshInitTimer</a> sturcture one can set some tricky data acquisition mode for device.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_timer.html" title="Direct timers control structure. ">RshInitTimer</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ab87bba0f65de1d3698ef563de17187ba"></a>RSH_CAPS_DEVICE_MEMORY_PER_CHANNEL</em>&nbsp;</td><td class="fielddoc">
<p>Device supports selection of individual block size for each analog channel. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6"></a>RSH_CAPS_DEVICE_FREQUENCY_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Device has predefined sampling rates list. </p>
<p>Frequency list can be obtained using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameter <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a519cd84aa5fa0a7d7f012f5992fb47bd" title="Device frequency list. ">RSH_GET_DEVICE_FREQUENCY_LIST</a>.<br/>
</p>
<dl class="section remark"><dt>Remarks</dt><dd>If device don't have frequency list, one can obtaind minimum and maximum sampling rates for device using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameters <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a309cca88c5ee5d2bc1e192ea86a0b0c6" title="Minimum value of device sample rate. ">RSH_GET_DEVICE_MIN_FREQUENCY</a> and <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a6532c40c817896f7079072eb6da91424" title="Maximum value of device sample rate. ">RSH_GET_DEVICE_MAX_FREQUENCY</a> accordingly. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a18a96c881cf6b541c631809b03034e37"></a>RSH_CAPS_DEVICE_SIZE_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Device has predefined buffer size list. </p>
<p>Buffer size list can be obtained using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameter <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a84c7ab578a3e499a6ee1a06e4dc2168f" title="List of allowable buffer sizes. ">RSH_GET_DEVICE_SIZE_LIST</a>.<br/>
</p>
<dl class="section remark"><dt>Remarks</dt><dd>All sizes in list are related to single channel, so if you use 2 channels (for example), you must pass 2 times larger buffer in <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Get (or send) data buffer to device. ">IRshDevice::GetData()</a> than size you set in <a class="el" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Buffer size in samples. ">RshInitADC::bufferSize</a> initialization parameter.</dd></dl>
<p>If device don't have size list, one can obtaind minimum and maximum sample size for device using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameters <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5af7d36047b4970c56ff7bce2fbaa243c7" title="Minimum number of counts (buffer size) per channel. ">RSH_GET_DEVICE_MIN_SAMPLES_PER_CHANNEL</a> and <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a0620cbce8027cae8f18140c8107593b3" title="Maximum number of counts (buffer size) per channel. ">RSH_GET_DEVICE_MAX_SAMPLES_PER_CHANNEL</a> accordingly. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9b7f3987af00b135e1b3c6db726ffc09"></a>RSH_CAPS_DEVICE_HAS_DIGITAL_PORT</em>&nbsp;</td><td class="fielddoc">
<p>Device has TTL lines for input (output). </p>
<p>One can obtain additinal information about digital ports installed using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5afe60859b2477277000383fa798df592d" title="Get data structure with information about device digital ports. ">RSH_GET_DEVICE_PORT_INFO</a> parameter. Obtained <a class="el" href="struct_rsh_board_port_info.html" title="Information about device digital ports. ">RshBoardPortInfo</a> structure contains all information you need to control digital input/output.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_board_port_info.html" title="Information about device digital ports. ">RshBoardPortInfo</a> | <a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7fa1a1277d1d227fb8a7384a35ed7773"></a>RSH_CAPS_DEVICE_GAIN_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Device has predefined list of gain coefficients. </p>
<p>One can get this list using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="List of gain values that can be used for analog channels. ">RSH_GET_DEVICE_GAIN_LIST</a> parameter.<br/>
 Input (or output) range of the device is divided by coefficients from list. For example, if device has input range 10V and we set gain equal 2, device will have input range 5V for the same bit range, so dynamic range will improve.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="List of gain values that can be used for analog channels. ">RSH_GET_DEVICE_GAIN_LIST</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a6639e7cecb677e7c977154484934e31d" title="Device analog channels input range for gain == 1. ">RSH_GET_DEVICE_INPUT_RANGE_VOLTS</a> | <a class="el" href="_rsh_functions_8h.html#a0f17b04cc19e92dcfb27bcc2ca45a211" title="Calculate [LSB/volts] conversion coefficient. ">RshLsbToVoltCoef</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac13ebe592ce8056360f9b390a8a28c83"></a>RSH_CAPS_DEVICE_GAINS_PER_CHANNEL</em>&nbsp;</td><td class="fielddoc">
<p>Gain coefficients can be set separately for each analog channel. </p>
<p>Gain coefficients can be obtained using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="List of gain values that can be used for analog channels. ">RSH_GET_DEVICE_GAIN_LIST</a> parameter. <br/>
 Gain coefficients can be set using <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitADC::channels</a> list.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Most of the rsh devices have this feature.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> | <a class="el" href="struct_rsh_init_a_d_c.html" title="Base initialization structure for ADC devices. ">RshInitADC</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="List of gain values that can be used for analog channels. ">RSH_GET_DEVICE_GAIN_LIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b"></a>RSH_CAPS_DEVICE_PREHISTORY</em>&nbsp;</td><td class="fielddoc">
<p>Prehistory data writing is availible. </p>
<p>Using <a class="el" href="struct_rsh_init_memory.html#a5d1d5e6e543365407f7de3ca71cc5fac" title="Prehistory size. ">RshInitMemory::preHistory</a> field one can choose, what part of databuffer will be used for saving "prehistory" data (before synchronization event occurred) and "history" data (after synchronization event occurred).</p>
<dl class="section remark"><dt>Remarks</dt><dd>Prehistory parameter is only used when working with synchronization.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a0e6752acbff305759924b0ef0034f57b" title="Get current prehistory size in counts. ">RSH_GET_DEVICE_PREHISTORY_SIZE</a> | <a class="el" href="page__synchronization.html">Synchronization</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85"></a>RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device supports double frequency data acquisition mode. </p>
<p>Some of high sampling rate devices with on board memory installed can operate in so called <b>double frequency</b> mode. For such devices, each analog channel usualy has its own ADC chip and when device is operated in normal mode, all ADC work in parralles, converting data from analog inputs.<br/>
 When double frequency mode is activated, 2 ADC start work with only one analog input (for most devices it is first channel, but for some you can chose what channel use for double frequency - see <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0" title="One can select what channel (channels) will be used in double (quadro) frequency mode. ">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a>).<br/>
 The result of this is that sampling rate (and buffer size) is doubled for selected channel, so if device has maximum sampling frequency 1GHz for example, in double frequency mode it will have ONLY one channel active, but with 2GHz sampling rate.<br/>
 Example:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_i_rsh_device.html" title="Interface is used to control almost all RSH ADC/DAC devices. ">IRshDevice</a>* device;</div>
<div class="line"></div>
<div class="line"><span class="comment">//obtain buffer size list available for double frequency mode</span></div>
<div class="line"><a class="code" href="class_rsh_buffer_type.html" title="Template class for buffer construction. ">RSH_BUFFER_U32</a> sizeList;</div>
<div class="line"><a class="code" href="_rsh_def_chk_8h.html#a811024d35b9b8a41095b1f583b649e56">U32</a> res = device-&gt;<a class="code" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">Get</a>(<a class="code" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a16d7bd1ab19a8278fdef1fe22ed1c1df" title="List of allowable buffer sizes in double frequency mode. ">RSH_GET_DEVICE_SIZE_LIST_DOUBLE</a>, &amp;sizeList); </div>
<div class="line"><span class="keywordflow">if</span>(res != <a class="code" href="_rsh_consts___status_codes_8h.html#af5c23a07b5f7e111ef15a9aa32b4e261a76893786bb0b2da5cda7d5a42ba52972" title=": No errors. ">RSH_API_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//GET-code is not supported, its ok</span></div>
<div class="line">    <span class="comment">// just use general size list with every size multipied by 2</span></div>
<div class="line">    res = device-&gt;<a class="code" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">Get</a>(<a class="code" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a84c7ab578a3e499a6ee1a06e4dc2168f" title="List of allowable buffer sizes. ">RSH_GET_DEVICE_SIZE_LIST</a>, &amp;sizeList); </div>
<div class="line">    <span class="keywordflow">if</span>(res != <a class="code" href="_rsh_consts___status_codes_8h.html#af5c23a07b5f7e111ef15a9aa32b4e261a76893786bb0b2da5cda7d5a42ba52972" title=": No errors. ">RSH_API_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//not good, this one should be available. process error</span></div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//multiply every size by 2</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;sizeList.<a class="code" href="class_rsh_buffer_type.html#ab295a287ef7a1bde6b5732ef2cb6c97e" title="Get actual buffer size in data elements. ">Size</a>(); ++i)</div>
<div class="line">        sizeList.<a class="code" href="class_rsh_buffer_type.html#a736f485e21c19f5f232e8fa061af4258" title="Direct pointer to allocated memory. ">ptr</a>[i] *= 2;</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//init structure</span></div>
<div class="line"><a class="code" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> params;</div>
<div class="line"></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Sampling rate in Hz. ">frequency</a> = 1e10+9; <span class="comment">//this parameters is ignored in double frequency mode</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_memory.html#a5ee43a023c53caef1a1ee30665407085" title="Set RshInitMemory::FreqDouble flag. ">SetFreqModeDouble</a>(); <span class="comment">//turn on double frequency mode</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Buffer size in samples. ">bufferSize</a> = sizeList[0];  <span class="comment">//size per channel</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//channel setup (for 2 channel device)</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">channels</a>[0].SetUsed();       <span class="comment">//this channel will be used for double frequency mode</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">channels</a>[1].SetUsed();       <span class="comment">// this flag will be ignored, only one channel may be selected in double frequency mode.</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Remarks</dt><dd>For block devices like oscillosopes, when 2 or more ADC board are combined in one multychannel device, total number of channels in double frequency mode is half its channels in normal mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0" title="One can select what channel (channels) will be used in double (quadro) frequency mode. ">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a29b7d124678551cd2ce885ce2857f12d"></a>RSH_CAPS_DEVICE_QUADRO_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device supports quadro frequency data acquisition mode. </p>
<p>This mode is similar to double frequency mode (<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Device supports double frequency data acquisition mode. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a>) only exception is that frequency is multiplied by 4 and not 2. Channel number is divided by 4, accordingly.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Device supports double frequency data acquisition mode. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba"></a>RSH_CAPS_DEVICE_AUTO_CALIBRATION</em>&nbsp;</td><td class="fielddoc">
<p>Device supports autocalibration. </p>
<p>Automatic internal calibration. Calibration procedure is device specific. For example, Leonardo II board adjust zero level for analog channels when one call <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> with RSH_GET_DEVICE_AUTO_CALIBRATION_SET parameter.</p>
<dl class="section remark"><dt>Remarks</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92" title="Abstraction library contains methods that allow automatic calibration perform. ">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> is not connected to this one! <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92" title="Abstraction library contains methods that allow automatic calibration perform. ">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> is active for device libraries that have imbeded calibration algorithms, used during device setup with external signal generation and measurement devices.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a39a86451f45417b3170a3f58efd563c7" title="Start automatic calibration process. ">RSH_GET_DEVICE_AUTO_CALIBRATION_SET</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1d7c7830ca32b68ec713eaf7196502b6"></a>RSH_CAPS_DEVICE_SYNCHRO_INTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Analog input of the device can be used as trigger source. </p>
<p>Using <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> initialization structure one can set treshold and select one of the input analog channels as trigger source. Synchronization slope and some other parameters are also programmable. After starting data acquisition using <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Start data acquisition or signal generation process. ">IRshDevice::Start()</a> method, synchronization event will be raised when signal on selected input will correspond to selected trigger settings.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4e931de0e0a4fb97becc7c552239d2fd"></a>RSH_CAPS_DEVICE_SYNCHRO_EXTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Device has additional input that can be used as trigger source. </p>
<p>Syncrhonization parameters (such as threshold, slope, filter use etc.) can be selected using <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure. After starting data acquisition using <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Start data acquisition or signal generation process. ">IRshDevice::Start()</a> method, synchronization event will be raised when signal on external sync input will correspond to selected trigger settings.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Usually external input differs from analog inputs - it can have its own input range, gain coefficients list, input resist switch, programmable filters, etc. All this parameters can be obtained using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method. All external synchronization specific parameters have <b>RSH_GET_DEVICE_EXT_SYNC</b> prefix, for example <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="List of external synchro input allowable gains. ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a>.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a819d7c0f4299baf67e2c592b78340105"></a>RSH_CAPS_DEVICE_EXTERNAL_START</em>&nbsp;</td><td class="fielddoc">
<p>Device has digital trigger. </p>
<p>Data acquisition process can be triggered using TTL signal. Information about signal connection, levels and condition to trigger can be found in device documentation or user manual.</p>
<dl class="section remark"><dt>Remarks</dt><dd>External start and external synchronization are not the same thing! </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a842258001468451ee1fd6850b26e1581"></a>RSH_CAPS_DEVICE_HYSTERESIS</em>&nbsp;</td><td class="fielddoc">
<p>Device has programmable hysteresis for synchronization. </p>
<p>Some devices with hardware digital synchronization have programmable hysteresis level feature.<br/>
 For more details about this option see <a class="el" href="struct_rsh_init_memory.html#a87c7c94337fcefa2dbca2e84f603b88a" title="Hysteresis. ">RshInitMemory::hysteresis</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html#a87c7c94337fcefa2dbca2e84f603b88a" title="Hysteresis. ">RshInitMemory::hysteresis</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> | <a class="el" href="page__synchronization.html">Synchronization</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a211335ed1c186623a20bbdd34ee5fb36"></a>RSH_CAPS_DEVICE_EXT_SYNC_GAIN_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Device have separate gain coefficients list for externl input. </p>
<p>External syncrhonization input often have its own gain list. You can get that list using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="List of external synchro input allowable gains. ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a> parameter.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If external synchronization input supports resist switch, you can get different lists for 50Ohm and 1MOhm modes using <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5abe43cede7b96f62a0a1198583f3b47de" title="List of external synchro input allowable gains for 50Ohm input. ">RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_50_OHM</a> and <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ae24bb732f8fa913c06d3b5b17050c29a" title="List of external synchro input allowable gains for 1MOhm input. ">RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_1_MOHM</a> constans accordingly.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="List of external synchro input allowable gains. ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a42cb2fa30a80c290cf5c912a66001285"></a>RSH_CAPS_DEVICE_EXT_SYNC_FILTER_LOW</em>&nbsp;</td><td class="fielddoc">
<p>High pass filter can be set on external syncrhonization input. </p>
<p>Filter pass band and other details are device specific, see user manual for more information.<br/>
 <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="External synchronization channel settings. ">RshInitMemory::channelSynchro</a> field of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> is used for external synchronization channel control. <a class="el" href="struct_rsh_synchro_channel.html#a06e3b68809075422733616aa8ed2c11fa8bb316fd68853752652e38d270fa5b7e" title="Turn on low pass filter for external trigger channel. ">RshSynchroChannel::FilterLow</a> bit must be set in <a class="el" href="struct_rsh_synchro_channel.html#afbd53e5994cba96221bc05415838ca71" title="Additional flags. ">RshSynchroChannel::control</a> field to turn filter on.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__e_n_8cpp-example.html">Example of external synchronization input setup</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6139d67568b35cfc2a7adde139fc1ec5"></a>RSH_CAPS_DEVICE_EXT_SYNC_FILTER_HIGH</em>&nbsp;</td><td class="fielddoc">
<p>Low pass filter can be set on external syncrhonization input. </p>
<p>Filter pass band and other details are device specific, see user manual for more information.<br/>
 <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="External synchronization channel settings. ">RshInitMemory::channelSynchro</a> field of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> is used for external synchronization channel control. <a class="el" href="struct_rsh_synchro_channel.html#a06e3b68809075422733616aa8ed2c11face336eda8b6dc0a609b4d30fce8784d3" title="Turn on high pass filter for external trigger channel. ">RshSynchroChannel::FilterHigh</a> bit must be set in <a class="el" href="struct_rsh_synchro_channel.html#afbd53e5994cba96221bc05415838ca71" title="Additional flags. ">RshSynchroChannel::control</a> field to turn filter on.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__e_n_8cpp-example.html">Example of external synchronization input setup</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ae08ef0174287786460f481831ccea3a8"></a>RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM</em>&nbsp;</td><td class="fielddoc">
<p>External synchronization input of the device has 50 Ohm resist mode. </p>
<p>If RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM is also available, one can switch between resist modes using <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="External synchronization channel settings. ">RshInitMemory::channelSynchro</a> field of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure. <br/>
 If 50Ohm is the only option, or neither of resist CAPS available, using this setting will take no effect.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When switching resist mode dont forget that modes have different gain lists and some features (as coupling) are available only for 1MOhm input mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056" title="AC/DC coupling of the external synchronization input can be changed. ">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__e_n_8cpp-example.html">Example of external synchronization input setup</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7ac24ea80e3d47378983f78763e13318"></a>RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM</em>&nbsp;</td><td class="fielddoc">
<p>External synchronization input of the device has 1 MOhm resist mode. </p>
<p>If RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM is also available, one can switch between resist modes using <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="External synchronization channel settings. ">RshInitMemory::channelSynchro</a> field of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure. <br/>
 If 1MOhm is the only option, or neither of resist CAPS available, using this setting will take no effect.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When switching resist mode dont forget that modes have different gain lists and some features (as coupling) are available only for 1MOhm input mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056" title="AC/DC coupling of the external synchronization input can be changed. ">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__e_n_8cpp-example.html">Example of external synchronization input setup</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056"></a>RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</em>&nbsp;</td><td class="fielddoc">
<p>AC/DC coupling of the external synchronization input can be changed. </p>
<p>In 1MOhm input mode one can switch between AC and DC mode of external synchronization channel using <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="External synchronization channel settings. ">RshInitMemory::channelSynchro</a> field of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure. <br/>
</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_synchro_channel.html" title="External trigger channel parameters. ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__e_n_8cpp-example.html">Example of external synchronization input setup</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a002451fcec1e06a5a45ef19cefc94a96"></a>RSH_CAPS_DEVICE_HAS_DAC_INSTALLED</em>&nbsp;</td><td class="fielddoc">
<p>Device have one or more DAC modules installed. </p>
<p>One can get access to DACs using <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method with <a class="el" href="struct_rsh_init_d_a_c.html" title="DAC control structure. ">RshInitDAC</a> initialization structure.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Do not confuse this feature with RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE. Second one is for devices which main feature is signal generation, such as GSPF. GSPF have internal buffer for data, attenuator and can play signals from buffer with different sampling frequencies.<br/>
 DAC installed on ADC board is quite simple, and can only set some voltage level on output node.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b" title="RshInitDAC initialization structure is supported by abstraction library. ">RSH_CAPS_SOFT_INIT_DAC</a> | <a class="el" href="struct_rsh_init_d_a_c.html" title="DAC control structure. ">RshInitDAC</a> | <a class="el" href="_rsh_init_d_a_c__e_n_8cpp-example.html">DAC control example</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abf6f85bf5eab39826a654553549b2316"></a>RSH_CAPS_DEVICE_INPUT_LEVEL_ADJUSTMENT</em>&nbsp;</td><td class="fielddoc">
<p>Device's analog channels have programmable hardware input level adjustment. </p>
<p>Usually, voltage range of this adjustment is equal to input voltage range. One can get access to this feature, using <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitADC::channels</a> list, via <a class="el" href="struct_rsh_channel.html#a4d439cfb01993d1b6a9bada675f3f5bd" title="Input voltage adjustment. ">RshChannel::adjustment</a> field.<br/>
 For example, device have input range ±25V, and we have sinus signal with mean value 20V and amplitude 10V. Without signal adjustment, we cant't see full signal (it will be cut off becouse maximum value will be 20+10 = 30 V). Setting <a class="el" href="struct_rsh_channel.html#a4d439cfb01993d1b6a9bada675f3f5bd" title="Input voltage adjustment. ">RshChannel::adjustment</a> parameter for this channel to -15V we will have signal on ADC input in range from 35-15=20V to 10-15=-5V, which is in range of our ADC and can be converted without losing anything.</p>
<dl class="section remark"><dt>Remarks</dt><dd>You can acheive similar result using <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ae07c02266bb6316aef1e935eb085b169" title="Set input to AC mode. ">RshChannel::AC</a> mode if <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="AC/DC coupling of the analog inputs can be changed. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> flag is available.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> | <a class="el" href="struct_rsh_init_a_d_c.html" title="Base initialization structure for ADC devices. ">RshInitADC</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d"></a>RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</em>&nbsp;</td><td class="fielddoc">
<p>AC/DC coupling of the analog inputs can be changed. </p>
<p>In 1MOhm input mode one can switch between AC and DC mode of analog input channels setting one of the flags (<a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ae07c02266bb6316aef1e935eb085b169" title="Set input to AC mode. ">RshChannel::AC</a> or <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769a0697a87cd110fb1efc9f2f7d379d659c" title="Set input to DC mode. ">RshChannel::DC</a>) in <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Additional flags. ">RshChannel::control</a> field for selected channel in <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitMemory::channels</a> list in <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> | <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="_rsh_channel_setup__e_n_8cpp-example.html">Channels setup example</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8ef713b84c323d70257b352ec1370075"></a>RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM</em>&nbsp;</td><td class="fielddoc">
<p>Analog input channels of the device has 50 Ohm resist mode. </p>
<p>If RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM is also available, one can switch between resist modes using <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Additional flags. ">RshChannel::control</a> field for selected channel in <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitMemory::channels</a> list of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure.<br/>
 If 50Ohm is the only option, or neither of resist CAPS available, using this setting will take no effect.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When switching resist mode dont forget that modes have different gain lists and some features (as coupling) are available only for 1MOhm input mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="AC/DC coupling of the analog inputs can be changed. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> | <a class="el" href="_rsh_channel_setup__e_n_8cpp-example.html">Channels setup example</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a06104c4dec442b75afaa51ed1f5dbdde"></a>RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM</em>&nbsp;</td><td class="fielddoc">
<p>Analog input channels of the device has 1 MOhm resist mode. </p>
<p>If RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM is also available, one can switch between resist modes using <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Additional flags. ">RshChannel::control</a> field for selected channel in <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitMemory::channels</a> list of <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> structure.<br/>
 If 1MOhm is the only option, or neither of resist CAPS available, using this setting will take no effect.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When switching resist mode dont forget that modes have different gain lists and some features (as coupling) are available only for 1MOhm input mode.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="AC/DC coupling of the analog inputs can be changed. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_channel.html" title="Analog channel parameters. ">RshChannel</a> | <a class="el" href="_rsh_channel_setup__e_n_8cpp-example.html">Channels setup example</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866afe2bb60b36d6727f6c772154b53487c0"></a>RSH_CAPS_DEVICE_FRAME_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device supports frame frequency mode. </p>
<p>In this mode one defines two frequencies:<br/>
 one used inside frame (determing time between channels) and the other outside (determing time between frames).<br/>
 This mode is useful when one need to acqure data with low sampling rate from several channels and use ADC with non-synchronious (multyplexed) channels. Without this mode, gaps between channels will be very large because of low frequency. But with frame frequency used, interval between channel can be small, when interval between frames can be large.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> | <a class="el" href="page__frame_freq_mode.html">Frame frequency data acquisition mode</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9b0777dfe1f4aae1634e1b93227005d0"></a>RSH_CAPS_DEVICE_PACKET_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device supports packet mode of data acquisition. </p>
<p>This mode is used for devices with internal memory installed. Such devices first acquire data to internal buffer (that can be several Mb long), and then transfer data using USB/PCI interface to PC. Second process is quite long, so if required data size is small, it will be waste of time on data transfer. <br/>
 Thus, packet mode is quite useful: one setup data block size using <a class="el" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Buffer size in samples. ">RshInitMemory::bufferSize</a> and number of blocks using <a class="el" href="struct_rsh_init_memory.html#a3543ce04d314091390cd636baf8723d6" title="Packet number. ">RshInitMemory::packetNumber</a> (obviously, <b>bufferSize*packetNumber</b> must be less then <b>MaximumMemory</b>, which one can obtain using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with parameter <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a82758a9373af6e92b9606633d83a2c67" title="Size of onboard device memory. ">RSH_GET_DEVICE_MEMORY_SIZE</a>). <br/>
 When data acquistion process will be started with <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Start data acquisition or signal generation process. ">IRshDevice::Start()</a> method, device will start acquistion (using all parameters such as trigger source etc.) multiple times until it got all <a class="el" href="struct_rsh_init_memory.html#a3543ce04d314091390cd636baf8723d6" title="Packet number. ">RshInitMemory::packetNumber</a> blocks and only after that will start transfer data to PC.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a72bc3e5be326765db46df01f989d8901"></a>RSH_CAPS_DEVICE_START_DELAY</em>&nbsp;</td><td class="fielddoc">
<p>Data acquisition process can be delayed (from trigger event). </p>
<p>When device work in syncrhonization mode, one can set time interval (<a class="el" href="struct_rsh_init_memory.html#aea66679c9372b4e0fa831ea3db5b19c7" title="Start delay. ">RshInitMemory::startDelay</a> field), and when synchronization event will be triggered, data writing will start not immediately, but after <b>startDelay</b> time elapsed.<br/>
 This setting is opposite to using <a class="el" href="struct_rsh_init_memory.html#a5d1d5e6e543365407f7de3ca71cc5fac" title="Prehistory size. ">RshInitMemory::preHistory</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="page__synchronization.html">Synchronization</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aab020fd08c44e6af6b9ff1ca657e59f5"></a>RSH_CAPS_DEVICE_SLAVE_MASTER_SWITCH</em>&nbsp;</td><td class="fielddoc">
<p>Data acquisition can be started from master device. </p>
<p>Using <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaae840f4e9feb73bd6ea90b452c898b977" title="Use master device as start trigger source. ">RshInitADC::Master</a> as <a class="el" href="struct_rsh_init_a_d_c.html#a3efbcf323a21adb0ba6de43ed3b5871f" title="Data acquisition start mode. ">RshInitADC::startType</a>, one can run device as slave. After call to <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Start data acquisition or signal generation process. ">IRshDevice::Start()</a> method device will be in waitng state (like synchronization), but wait for signal from master device.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This feature is mostly used in systems where several identical devices are used for syncrhonious data acquisition. Special link between devices is required for this feature to work. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ae0218b6df2f5e3cef65793b25a48389a"></a>RSH_CAPS_DEVICE_SYNCHRO_CHANNELS</em>&nbsp;</td><td class="fielddoc">
<p>Device's channels are synchronous. </p>
<p>If this flag is active, the device have separate ADC for each of analog channels, all ADCs are started by common clock signal and data from all channels acquired simultaniously.<br/>
 If opposite is true, device only have one ADC and channels are multyplexed. All samples have intervals equal to 1/F between them, where F is sampling frequency.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If device dont support this feature, its maximum frequency is always divided by number of channels used. For example, if device have maximum sampling rate equal to 500kHz, when using 2 channels one can only set <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Sampling rate in Hz. ">RshInitADC::frequency</a> field to 250kHz.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_a_d_c.html" title="Base initialization structure for ADC devices. ">RshInitADC</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9f291ff9cb8c78e6cc63fe9dd7732001"></a>RSH_CAPS_DEVICE_EXTERNAL_FREQUENCY</em>&nbsp;</td><td class="fielddoc">
<p>ADC can be sampled by external signal source. </p>
<p>To turn on this feature use <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaa77f738f46a81db5a1dff418cab5c78f7" title="Use external frequency source for sampling. ">RshInitADC::FrequencyExternal</a> bit in <a class="el" href="struct_rsh_init_a_d_c.html#a3efbcf323a21adb0ba6de43ed3b5871f" title="Data acquisition start mode. ">RshInitADC::startType</a> field of initialization structure. One can combine this flag (using OR state) with some other startType flags, like <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaa9db2e34cceb99c7fe481cfa58a7a3cb3" title="Timer start. ">RshInitADC::Timer</a> or <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaaa85aaa4fbccb5d9ef642002a37203c98" title="Internal synchronization. ">RshInitADC::Internal</a>.<br/>
 Parameters of signal to use as sampling source can be find in device's user manual.</p>
<dl class="section remark"><dt>Remarks</dt><dd>When using this feature, <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Sampling rate in Hz. ">RshInitADC::frequency</a> field is still used (in most devices) to determine what frequency divider will be used.<br/>
 For example, if maximum sampling rate for device is 500kHz, and 150кHz external sampling source is used, when <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Sampling rate in Hz. ">RshInitADC::frequency</a> is set to 250kHz, then divider = 500/250 = 2 will be applyed to external frequency signal, producing 150/2 = 75kHz sample rate. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abbd6a3d6733d7e318c076e5dc28c23f1"></a>RSH_CAPS_DEVICE_FREQUENCY_SWITCH_PREHISTORY</em>&nbsp;</td><td class="fielddoc">
<p>Sampling rate can be changed after trigger event. </p>
<p>If this feature is available, one can use two different sampling rates for "prehistory" and "data" parts of the buffer. History sampling rate has two fixed values F1 = Fmax and F2 = Fmax/8. See device documentation for more details. One can turn this feature on using <a class="el" href="struct_rsh_init_a_d_c.html#ae62d171ab48740511a0571263a9e3939ae967f9ca6620011f8f83ff414c92ac47" title="Sampling rates for history and prehistory are different (switch to high frequency). ">RshInitMemory::FrequencySwitchToMaximum</a> or <a class="el" href="struct_rsh_init_a_d_c.html#ae62d171ab48740511a0571263a9e3939aec69366ab34f2397535633973ed45fdc" title="Sampling rates for history and prehistory are different (switch to low frequency). ">RshInitMemory::FrequencySwitchToMinimum</a> flag in <a class="el" href="struct_rsh_init_a_d_c.html#acbd0e3074cc4af0a7228093bd81b9161" title="Additional synchonization options. ">RshInitMemory::controlSynchro</a> field of initialization structure.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b" title="Prehistory data writing is availible. ">RSH_CAPS_DEVICE_PREHISTORY</a> | <a class="el" href="page__synchronization.html">Synchronization</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0"></a>RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</em>&nbsp;</td><td class="fielddoc">
<p>One can select what channel (channels) will be used in double (quadro) frequency mode. </p>
<p>If this feature is available, one can specify which channel (or channels) will be used when double frequency mode is activated. If not, zero channel (or even channels if there are more than two of them) will always selected for double frequency mode. Channel selection is performed using standart <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ab1f9ac172ca4a0c1bb0fd95585e3bd6f" title="Channel will be used in data acquisition. ">RshChannel::Used</a> flag in <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Analog channels settings. ">RshInitMemory::channels</a> list.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This feature is relevant for quadro frequency too, one (obvious) except is that one can select only one channel from every four.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Device supports double frequency data acquisition mode. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> | <a class="el" href="_i_rsh_device__double_freq_mode__e_n_8cpp-example.html">Init parameters example</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1ea35492c22a13ec7ed1d04bb46b19b1"></a>RSH_CAPS_DEVICE_DIFFERENTIAL_INPUT_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device can be programmably configure to acquire data in unipolar/ bipolar mode. </p>
<p>Devices work in unipolar mode by default. One need set <a class="el" href="struct_rsh_init_d_m_a.html#ad85b05bbb1e37cffbefce3c074a9aa02a8ab8ed214bc57f8c4b30d3acbb84bcb1" title="Turn on differential mode. ">RshInitDMA::DiffMode</a> flag of <a class="el" href="struct_rsh_init_d_m_a.html#a2ab1a6e058c24c69aa320d0d8b0e9633" title="Additional options. ">RshInitDMA::control</a> field to set device in bipolar mode.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Channels number will be divided by 2, and input lines for analog channels must be connected according user manual.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a729f46ef82a336136a8d9c2b2ff4864c"></a>RSH_CAPS_DEVICE_FLASH_INFO_ONBOARD</em>&nbsp;</td><td class="fielddoc">
<p>There is a flash memory unit onboard for device information. </p>
<p>This flag indicates that device has onboard flash memory which is used for additional information such as serial number. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866adc0c2c58e598217f009c8da5d6a32355"></a>RSH_CAPS_DEVICE_GPS_MODULE_INSTALLED</em>&nbsp;</td><td class="fielddoc">
<p>Device have GPS module. </p>
<p>One can obtain GPS data using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a358aa4d0b4c731a0768cee1368095125" title="Get GPS data. ">RSH_GET_DEVICE_GPS_DATA</a> or <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ae56834ed5210a3985bcb58aa5b75d1e8" title="Get GPS data as unicode string. ">RSH_GET_DEVICE_GPS_DATA_UTF16</a> constants.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Format of GPS sentance string is device (and module) dependend, see device manual for details. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4a5a6e1eaea445c32aa1e7b859f79547"></a>RSH_CAPS_DEVICE_AUTO_START_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Device supports automatic restart. </p>
<p>Device can be proggrammed in such a way that it will automatically restart data acquisition using internal timing interval. This interval can be set using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a503bd52901c5f2996212c757abe61564" title="Set autostart interval. ">RSH_GET_DEVICE_AUTO_START_INTERVAL_SET</a> parameter.<br/>
</p>
<dl class="section remark"><dt>Remarks</dt><dd>This mode is not continuous mode. Data buffers obtained are not continuous. The only difference from "Start-Stop" mode is that one do not have to start data acquisition for each buffer - device hardware will do it.<br/>
 From programming point of view, however, work process look much like work in continuous mode - one have to init device, start it, and then wait to interrupt events (one for each bufer) infinitely, until <a class="el" href="struct_i_rsh_device.html#a58ed2025368f7aabe6db1ac49b56b553" title="Stop data acquisition or signal generation process. ">IRshDevice::Stop()</a> method is called. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac2dd322d1bd59b2cfd167b88f55baff0"></a>RSH_CAPS_DEVICE_DIGITAL_PORT_DATA_WITH_ANALOG_DATA</em>&nbsp;</td><td class="fielddoc">
<p>Digital line data can be contained within analog data. </p>
<p>Device digital lines data (input digital port for ADC devices) can be placed in last significant bits of analog data.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Use special <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Get (or send) data buffer to device. ">IRshDevice::GetData()</a> flag ( <a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="State of digital input lines is transfered within data. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a>) to transfer digital port data with analog data (for ADC devices) or to output digital lines (for GSPF devices). See <a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="State of digital input lines is transfered within data. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a> for details.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="State of digital input lines is transfered within data. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92"></a>RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow automatic calibration perform. </p>
<p>This flag indicates that device can be calibrated programmably, with use of external signal generation and measurement devices.<br/>
 Do not confuse with <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba" title="Device supports autocalibration. ">RSH_CAPS_DEVICE_AUTO_CALIBRATION</a> (automatic calibration of device during runtime). This flag is for preproduction process only. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aefaad7f3baecfb66eeff2f68be7e0a9d"></a>RSH_CAPS_SOFT_GATHERING_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow data acquisition in "start-stop" mode. </p>
<p>Device can be programmed to acquire data in "Start-Stop" mode. In this mode only one data block of predefined size will be acquired and transfered to user. This is most common scenario of work.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> | <a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866acfd92070f34276c75c9cef5f486fb246"></a>RSH_CAPS_SOFT_PGATHERING_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow continious data acquisition. </p>
<p>In this mode device's ADC is started once, and then acquire data continiously, generating interrupt each time data block is ready. This process can be active long time, and stops only when <a class="el" href="struct_i_rsh_device.html#a58ed2025368f7aabe6db1ac49b56b553" title="Stop data acquisition or signal generation process. ">IRshDevice::Stop()</a> method is called.</p>
<dl class="section remark"><dt>Remarks</dt><dd>Due to brandwidth limitation for computer interfaces, this mode only available for low frequency (10MHz maximum) devices</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ad726d65aed23416c15896fde9429c91e"></a>RSH_CAPS_SOFT_DIGITAL_PORT_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow control of digital port. </p>
<p>Using <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method and <a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> structure one can write and read data from digital port. Information about digital port can be obtained using <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Access to different information about device and abstraction library. ">IRshDevice::Get()</a> method with <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5afe60859b2477277000383fa798df592d" title="Get data structure with information about device digital ports. ">RSH_GET_DEVICE_PORT_INFO</a> parameter.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> | <a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> | <a class="el" href="struct_rsh_port_info.html" title="Information about digital port. ">RshPortInfo</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a32c747c421e618cb1140269dace49079"></a>RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow signal generation. </p>
<p>Using <a class="el" href="struct_rsh_init_g_s_p_f.html" title="Initialization structure for signal generators. ">RshInitGSPF</a> stucture one can set generation parameters, and then send data buffer to device using <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Get (or send) data buffer to device. ">IRshDevice::GetData()</a> method.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_g_s_p_f.html" title="Initialization structure for signal generators. ">RshInitGSPF</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a5ed5faedf3212a6c617025124db414ce"></a>RSH_CAPS_SOFT_INIT_MEMORY</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is usually used for high frequency devices with internal memory installed.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Initialization structure for Memory-type devices. ">RshInitMemory</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6b5450990b92306f3c288cd8325be52c"></a>RSH_CAPS_SOFT_INIT_DMA</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is usually used for low frequency devices.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Initialization structure for DMA-type devices. ">RshInitDMA</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866adefc92cd8599903fa80aa6a5b100b837"></a>RSH_CAPS_SOFT_INIT_GSPF</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_g_s_p_f.html" title="Initialization structure for signal generators. ">RshInitGSPF</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is used for programming GSPF family devices.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_g_s_p_f.html" title="Initialization structure for signal generators. ">RshInitGSPF</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a91e93fec1d767db707c24a2d9893d634"></a>RSH_CAPS_SOFT_INIT_VOLTMETER</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_voltmeter.html" title="Initialization structure for voltmeter V7-78. ">RshInitVoltmeter</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is used for programming VISA-based digital voltmeters.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_voltmeter.html" title="Initialization structure for voltmeter V7-78. ">RshInitVoltmeter</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aa3e2fe9f73f6764cf89f870e782a1d74"></a>RSH_CAPS_SOFT_INIT_TIMER</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_timer.html" title="Direct timers control structure. ">RshInitTimer</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is used for direct control of counter timer.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_timer.html" title="Direct timers control structure. ">RshInitTimer</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> | <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df" title="Device has 3 channel Intel 8254 PIT chip installed. ">RSH_CAPS_DEVICE_TIMER_8254</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a12ec3905812e467bfcb3be66da310ec8"></a>RSH_CAPS_SOFT_STROBOSCOPE</em>&nbsp;</td><td class="fielddoc">
<p>Abstraction library contains methods that allow use of software stoboscope. </p>
<p>Stroboscope only work with synchronization and periodic signals. Obtaining information about precise time of synchronization event and interpolate several signal realisation to one output signal with better resolution in time domain. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b"></a>RSH_CAPS_SOFT_INIT_DAC</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_d_a_c.html" title="DAC control structure. ">RshInitDAC</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is used for DAC control</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_d_a_c.html" title="DAC control structure. ">RshInitDAC</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a64b485141c3711ba52383ba4990f3620"></a>RSH_CAPS_SOFT_INIT_PORT</em>&nbsp;</td><td class="fielddoc">
<p><a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> initialization structure is supported by abstraction library. </p>
<p>One can use this structure as parameter for <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> method.</p>
<dl class="section remark"><dt>Remarks</dt><dd>This structure is used for digital port access</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="struct_rsh_init_port.html" title="Digital port operations. ">RshInitPort</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Setup data acquisition parameters. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4013f7fb7ad5fa0e49b5b1a950daec30"></a>RSH_CAPS_SOFT_TUNER_MODE_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Internal device parameters can be tuned using this abstraction library. </p>
<p>Special private set of methods and structures is used to change internal device parameters. Tuner is used only for initial device configuration and pre-sale preparation. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a74a0c31f5093f34767ed96ba1f48c0b7"></a>RSH_CAPS_MAX</em>&nbsp;</td><td class="fielddoc">
<p>Maximum number of values in RSH_CAPS enum. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Dec 30 2015 12:21:55 for Rsh API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
