<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>Rsh API: Файл G:/SDK2/HEADERS/Include/RshConsts_CapsCodes.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rsh.bmp"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Rsh API
   &#160;<span id="projectnumber">SDK 2.1</span>
   </div>
   <div id="projectbrief">Документация по программированию</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li class="current"><a href="files.html"><span>Файлы</span></a></li>
      <li><a href="page__examples.html"><span>Примеры</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li><a href="globals.html"><span>Список&#160;членов&#160;всех&#160;файлов</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Файлы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Переменные</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Определения типов</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Перечисления</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Элементы перечислений</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Друзья</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Макросы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Страницы</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_2eb228eaf9aee299c66d8fb3a868065e.html">HEADERS</a></li><li class="navelem"><a class="el" href="dir_247cc5d6a0059d721fe6b5dcc5a7b566.html">Include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#enum-members">Перечисления</a>  </div>
  <div class="headertitle">
<div class="title">Файл RshConsts_CapsCodes.h</div>  </div>
</div><!--header-->
<div class="contents">

<p>Константы возможностей CAPS для Rsh SDK.  
<a href="#details">Подробнее...</a></p>
<div class="textblock"><div class="dynheader">
Граф файлов, в которые включается этот файл:</div>
<div class="dyncontent">
<div class="center"><img src="_rsh_consts___caps_codes_8h__dep__incl.png" border="0" usemap="#_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep" alt=""/></div>
<map name="_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep" id="_g_1_2_s_d_k2_2_h_e_a_d_e_r_s_2_include_2_rsh_consts___caps_codes_8hdep">
<area shape="rect" id="node2" href="_rsh_consts_8h.html" title="Данный файл включает в себя все заголовочные файлы с константами из RSH SDK. " alt="" coords="5,99,219,143"/><area shape="rect" id="node5" href="_rsh_caps_description_8h.html" title="Простая структура для хранения описаний капс&#45;кодов " alt="" coords="243,99,457,143"/><area shape="rect" id="node3" href="_rsh_api_8h.html" title="Главный заголовочный файл RSH API. " alt="" coords="5,193,219,237"/><area shape="rect" id="node4" href="_rsh_api_8cpp.html" title="Объединение всех cpp файлов, входящих в состав SDK. " alt="" coords="5,286,219,330"/></map>
</div>
</div>
<p><a href="_rsh_consts___caps_codes_8h_source.html">См. исходные тексты.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Перечисления</h2></td></tr>
<tr class="memitem:a7d002d179754641063bf0db5344f5866"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">RSH_CAPS</a> { <br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a0cdac3b59f68c304f552fcf2a5e2cddb">RSH_CAPS_DEVICE_PCI</a> = 0, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a142967aefc516c7ca805802a355137bf">RSH_CAPS_DEVICE_PCI_EXPRESS</a> = 1, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abcb2ae69029c641240b6b1b18bc680da">RSH_CAPS_DEVICE_USB1_1</a> = 2, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866add7224aea95d9a4a555e57b98be050c1">RSH_CAPS_DEVICE_USB2_0</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9f88b48187f74e19cc49cf4598fac023">RSH_CAPS_DEVICE_USB3_0</a> = 4, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac8d5c7767649c7be6aeae9589fc8e3a7">RSH_CAPS_DEVICE_ETHERNET</a> = 5, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1b10048c646f00eb3145b59ca496581b">RSH_CAPS_DEVICE_FREQUENCY_SYNTHESIZER</a> = 15, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df">RSH_CAPS_DEVICE_TIMER_8254</a> = 16, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ab87bba0f65de1d3698ef563de17187ba">RSH_CAPS_DEVICE_MEMORY_PER_CHANNEL</a> = 17, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6">RSH_CAPS_DEVICE_FREQUENCY_LIST</a> = 18, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a18a96c881cf6b541c631809b03034e37">RSH_CAPS_DEVICE_SIZE_LIST</a> = 19, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9b7f3987af00b135e1b3c6db726ffc09">RSH_CAPS_DEVICE_HAS_DIGITAL_PORT</a> = 20, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7fa1a1277d1d227fb8a7384a35ed7773">RSH_CAPS_DEVICE_GAIN_LIST</a> = 21, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac13ebe592ce8056360f9b390a8a28c83">RSH_CAPS_DEVICE_GAINS_PER_CHANNEL</a> = 22, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b">RSH_CAPS_DEVICE_PREHISTORY</a> = 23, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> = 24, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a29b7d124678551cd2ce885ce2857f12d">RSH_CAPS_DEVICE_QUADRO_FREQUENCY_MODE</a> = 25, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba">RSH_CAPS_DEVICE_AUTO_CALIBRATION</a> = 26, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1d7c7830ca32b68ec713eaf7196502b6">RSH_CAPS_DEVICE_SYNCHRO_INTERNAL</a> = 27, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4e931de0e0a4fb97becc7c552239d2fd">RSH_CAPS_DEVICE_SYNCHRO_EXTERNAL</a> = 28, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a819d7c0f4299baf67e2c592b78340105">RSH_CAPS_DEVICE_EXTERNAL_START</a> = 29, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a842258001468451ee1fd6850b26e1581">RSH_CAPS_DEVICE_HYSTERESIS</a> = 30, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a211335ed1c186623a20bbdd34ee5fb36">RSH_CAPS_DEVICE_EXT_SYNC_GAIN_LIST</a> = 31, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a42cb2fa30a80c290cf5c912a66001285">RSH_CAPS_DEVICE_EXT_SYNC_FILTER_LOW</a> = 32, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6139d67568b35cfc2a7adde139fc1ec5">RSH_CAPS_DEVICE_EXT_SYNC_FILTER_HIGH</a> = 33, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ae08ef0174287786460f481831ccea3a8">RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM</a> = 34, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7ac24ea80e3d47378983f78763e13318">RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM</a> = 35, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> = 36, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a002451fcec1e06a5a45ef19cefc94a96">RSH_CAPS_DEVICE_HAS_DAC_INSTALLED</a> = 37, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abf6f85bf5eab39826a654553549b2316">RSH_CAPS_DEVICE_INPUT_LEVEL_ADJUSTMENT</a> = 38, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> = 39, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8ef713b84c323d70257b352ec1370075">RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM</a> = 40, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a06104c4dec442b75afaa51ed1f5dbdde">RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM</a> = 41, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866afe2bb60b36d6727f6c772154b53487c0">RSH_CAPS_DEVICE_FRAME_FREQUENCY_MODE</a> = 43, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9b0777dfe1f4aae1634e1b93227005d0">RSH_CAPS_DEVICE_PACKET_MODE</a> = 44, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a72bc3e5be326765db46df01f989d8901">RSH_CAPS_DEVICE_START_DELAY</a> = 45, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aab020fd08c44e6af6b9ff1ca657e59f5">RSH_CAPS_DEVICE_SLAVE_MASTER_SWITCH</a> = 46, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ae0218b6df2f5e3cef65793b25a48389a">RSH_CAPS_DEVICE_SYNCHRO_CHANNELS</a> = 47, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9f291ff9cb8c78e6cc63fe9dd7732001">RSH_CAPS_DEVICE_EXTERNAL_FREQUENCY</a> = 48, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abbd6a3d6733d7e318c076e5dc28c23f1">RSH_CAPS_DEVICE_FREQUENCY_SWITCH_PREHISTORY</a> = 49, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a> = 50, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a1ea35492c22a13ec7ed1d04bb46b19b1">RSH_CAPS_DEVICE_DIFFERENTIAL_INPUT_MODE</a> = 51, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a729f46ef82a336136a8d9c2b2ff4864c">RSH_CAPS_DEVICE_FLASH_INFO_ONBOARD</a> = 52, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866adc0c2c58e598217f009c8da5d6a32355">RSH_CAPS_DEVICE_GPS_MODULE_INSTALLED</a> = 53, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4a5a6e1eaea445c32aa1e7b859f79547">RSH_CAPS_DEVICE_AUTO_START_MODE</a> = 54, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ac2dd322d1bd59b2cfd167b88f55baff0">RSH_CAPS_DEVICE_DIGITAL_PORT_DATA_WITH_ANALOG_DATA</a> = 55, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> = 512, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aefaad7f3baecfb66eeff2f68be7e0a9d">RSH_CAPS_SOFT_GATHERING_IS_AVAILABLE</a> = 513, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866acfd92070f34276c75c9cef5f486fb246">RSH_CAPS_SOFT_PGATHERING_IS_AVAILABLE</a> = 514, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866ad726d65aed23416c15896fde9429c91e">RSH_CAPS_SOFT_DIGITAL_PORT_IS_AVAILABLE</a> = 515, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a32c747c421e618cb1140269dace49079">RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE</a> = 516, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a5ed5faedf3212a6c617025124db414ce">RSH_CAPS_SOFT_INIT_MEMORY</a> = 517, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6b5450990b92306f3c288cd8325be52c">RSH_CAPS_SOFT_INIT_DMA</a> = 518, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866adefc92cd8599903fa80aa6a5b100b837">RSH_CAPS_SOFT_INIT_GSPF</a> = 519, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a91e93fec1d767db707c24a2d9893d634">RSH_CAPS_SOFT_INIT_VOLTMETER</a> = 520, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866aa3e2fe9f73f6764cf89f870e782a1d74">RSH_CAPS_SOFT_INIT_TIMER</a> = 521, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a12ec3905812e467bfcb3be66da310ec8">RSH_CAPS_SOFT_STROBOSCOPE</a> = 522, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b">RSH_CAPS_SOFT_INIT_DAC</a> = 523, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a64b485141c3711ba52383ba4990f3620">RSH_CAPS_SOFT_INIT_PORT</a> = 524, 
<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4013f7fb7ad5fa0e49b5b1a950daec30">RSH_CAPS_SOFT_TUNER_MODE_IS_AVAILABLE</a> = 525, 
<br/>
&#160;&#160;<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a74a0c31f5093f34767ed96ba1f48c0b7">RSH_CAPS_MAX</a> = 1024
<br/>
 }</td></tr>
<tr class="memdesc:a7d002d179754641063bf0db5344f5866"><td class="mdescLeft">&#160;</td><td class="mdescRight">Список возможностей устройства и программного обеспечения  <a href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">Подробнее...</a><br/></td></tr>
<tr class="separator:a7d002d179754641063bf0db5344f5866"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Константы возможностей CAPS для Rsh SDK. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>JSC "Rudnev-Shilyaev"</dd></dl>
<dl class="section date"><dt>Дата</dt><dd>10.12.2015 </dd></dl>
<dl class="section version"><dt>Версия</dt><dd>1.0 [SDK 2.1] </dd></dl>
</div><h2 class="groupheader">Перечисления</h2>
<a class="anchor" id="a7d002d179754641063bf0db5344f5866"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866">RSH_CAPS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Список возможностей устройства и программного обеспечения </p>
<p>Позволяет узнать, какие возможности поддерживаются устройством и библиотекой абстракции, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ac5d41944239efbcfa7b5b9e1d65e9aa9" title="Определение возможностей устройства и библиотеки. ">RSH_GET_DEVICE_IS_CAPABLE</a>.<br/>
</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> | <a class="el" href="_i_rsh_device__get__r_s_h__g_e_t__d_e_v_i_c_e__i_s__c_a_p_a_b_l_e__r_u_8cpp-example.html">Пример использования </a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Элементы перечислений</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a0cdac3b59f68c304f552fcf2a5e2cddb"></a>RSH_CAPS_DEVICE_PCI</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом PCI. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a142967aefc516c7ca805802a355137bf"></a>RSH_CAPS_DEVICE_PCI_EXPRESS</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом PCI Express. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abcb2ae69029c641240b6b1b18bc680da"></a>RSH_CAPS_DEVICE_USB1_1</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом USB 1.1. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866add7224aea95d9a4a555e57b98be050c1"></a>RSH_CAPS_DEVICE_USB2_0</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом USB 2.0. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9f88b48187f74e19cc49cf4598fac023"></a>RSH_CAPS_DEVICE_USB3_0</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом USB 3.0. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac8d5c7767649c7be6aeae9589fc8e3a7"></a>RSH_CAPS_DEVICE_ETHERNET</em>&nbsp;</td><td class="fielddoc">
<p>Устройство с интерфейсом Ethernet. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1b10048c646f00eb3145b59ca496581b"></a>RSH_CAPS_DEVICE_FREQUENCY_SYNTHESIZER</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет синтезатор частоты. </p>
<p>Синтезатор частоты позволяет плавно изменять частоту дискретизации, в отличие от устройств с делителем частоты, у которых есть некая максимальная частота дискретизации Fmax и кратные ей частоты Fmax/2, Fmax/4 и т.д.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Некоторые устройства с установленным синтезатором частоты НЕ ПОДДЕРЖИВАЮТ возможность произвольного выбора частоты дискретизации. Проверить наличие предопределенного списка поддерживаемых частот можно с помощью <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6" title="Устройство имеет таблицу фиксированных частот квантования. ">RSH_CAPS_DEVICE_FREQUENCY_LIST</a>.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6" title="Устройство имеет таблицу фиксированных частот квантования. ">RSH_CAPS_DEVICE_FREQUENCY_LIST</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a519cd84aa5fa0a7d7f012f5992fb47bd" title="Таблица допустимых частот дискретизации ">RSH_GET_DEVICE_FREQUENCY_LIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df"></a>RSH_CAPS_DEVICE_TIMER_8254</em>&nbsp;</td><td class="fielddoc">
<p>В устройстве установлен программируемый счетчик-таймер Intel 8254. </p>
<p>Используя структуру инициализации <a class="el" href="struct_rsh_init_timer.html" title="Прямое управление таймерами ">RshInitTimer</a> можно задать нестандартный режим сбора данных.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_timer.html" title="Прямое управление таймерами ">RshInitTimer</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ab87bba0f65de1d3698ef563de17187ba"></a>RSH_CAPS_DEVICE_MEMORY_PER_CHANNEL</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает возможность задать произвольный размер блока для каждого измерительного канала. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8f4f4950e3b592db3306546be39035f6"></a>RSH_CAPS_DEVICE_FREQUENCY_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет таблицу фиксированных частот квантования. </p>
<p>Список частот дискретизации может быть получен с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a519cd84aa5fa0a7d7f012f5992fb47bd" title="Таблица допустимых частот дискретизации ">RSH_GET_DEVICE_FREQUENCY_LIST</a>.<br/>
</p>
<dl class="section remark"><dt>Прим.</dt><dd>Если у устройства нет таблицы частот, можно получить минимальную и максимальную возможные частоты квантования, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметрами <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a309cca88c5ee5d2bc1e192ea86a0b0c6" title="Минимально возможная частота дискретизации ">RSH_GET_DEVICE_MIN_FREQUENCY</a> и <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a6532c40c817896f7079072eb6da91424" title="Максимально возможная частота дискретизации ">RSH_GET_DEVICE_MAX_FREQUENCY</a> соответственно. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a18a96c881cf6b541c631809b03034e37"></a>RSH_CAPS_DEVICE_SIZE_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет таблицу фиксированных размеров. </p>
<p>Список частот дискретизации может быть получен с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a84c7ab578a3e499a6ee1a06e4dc2168f" title="Список допустимых размеров блоков собираемых данных ">RSH_GET_DEVICE_SIZE_LIST</a>.<br/>
</p>
<dl class="section remark"><dt>Прим.</dt><dd>Все размеры в таблице размеров приведены на канал, т.е. если используется 2 канала (например), в метод <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Получение (или отправка) буфера с данными. ">IRshDevice::GetData()</a> нужно передать буфер в два раза большего размера, чем заданное значение параметра инициализации <a class="el" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Размер буфера в отсчетах ">RshInitADC::bufferSize</a>.</dd></dl>
<p>Если у устройства нет таблицы размеров, можно получить минимальный и максимальный допустимый размер в отсчетах на канал, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметрами <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5af7d36047b4970c56ff7bce2fbaa243c7" title="Минимальное количество отсчетов (размер буфера) на канал ">RSH_GET_DEVICE_MIN_SAMPLES_PER_CHANNEL</a> и <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a0620cbce8027cae8f18140c8107593b3" title="Максимальное количество отсчетов (размер буфера) на канал ">RSH_GET_DEVICE_MAX_SAMPLES_PER_CHANNEL</a> соответственно. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9b7f3987af00b135e1b3c6db726ffc09"></a>RSH_CAPS_DEVICE_HAS_DIGITAL_PORT</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет цифровые линии для ввода (вывода) данных </p>
<p>Дополнительную информацию о цифровых портах устройства можно получить, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5afe60859b2477277000383fa798df592d" title="Получeние структуры из со служебной информацией о портах ">RSH_GET_DEVICE_PORT_INFO</a>. Полученная структура <a class="el" href="struct_rsh_board_port_info.html" title="Информация о цифровых портах устройства ">RshBoardPortInfo</a> содержит все необходимые данные для организации управления цифровыми вводом/выводом.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_board_port_info.html" title="Информация о цифровых портах устройства ">RshBoardPortInfo</a> | <a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7fa1a1277d1d227fb8a7384a35ed7773"></a>RSH_CAPS_DEVICE_GAIN_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет таблицу коэффициентов усиления. </p>
<p>Получить список коэффициентов усиления можно с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="Список допустимых коэффициентов усиления ">RSH_GET_DEVICE_GAIN_LIST</a>. <br/>
 При использовании коэффициента усиления отличного от 1.0, входной (или выходной) диапазон устройства делится на этот коэффициент усиления, позволяя более полно задействовать динамический диапазон АЦП при работе со слабыми сигналами.<br/>
 Например, если устройство имеет входной диапазон 10В и 12 бит, вся шкала от 0 до 4096МЗР соотвествует напряжению от -10 до +10В. Использование коэффициента усиления равного 2 ставит в соответствие тому же диапазону (от 0 до 4096МЗР) напряжение от -5 до +5В, таким образом цена одного МЗР становится в два раза меньше. Правильно выбрав коэффициент усиления, можно более точно измерить слабый сигнал.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="Список допустимых коэффициентов усиления ">RSH_GET_DEVICE_GAIN_LIST</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a6639e7cecb677e7c977154484934e31d" title="Входной диапазон в вольтах при коэффициенте усиления 1. ">RSH_GET_DEVICE_INPUT_RANGE_VOLTS</a> | <a class="el" href="_rsh_functions_8h.html#a0f17b04cc19e92dcfb27bcc2ca45a211" title="Вычисление коэффициента преобразования [МЗР/Вольт]. ">RshLsbToVoltCoef</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac13ebe592ce8056360f9b390a8a28c83"></a>RSH_CAPS_DEVICE_GAINS_PER_CHANNEL</em>&nbsp;</td><td class="fielddoc">
<p>Поддерживается установка коэффициента усиления индивидуально для каждого канала. </p>
<p>Список коэффициентов усиления может быть получен с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="Список допустимых коэффициентов усиления ">RSH_GET_DEVICE_GAIN_LIST</a>. <br/>
 Устанавливаются коэффиценты усиления в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitADC::channels</a> структуры инициализации.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Большинство устройств поддерживают эту возможность.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> | <a class="el" href="struct_rsh_init_a_d_c.html" title="Базовая структура инициализации для АЦП устройств ">RshInitADC</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a7858f60e1ce8cb17a76e0130765104dd" title="Список допустимых коэффициентов усиления ">RSH_GET_DEVICE_GAIN_LIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b"></a>RSH_CAPS_DEVICE_PREHISTORY</em>&nbsp;</td><td class="fielddoc">
<p>Доступна возможность записи предыстории измерения. </p>
<p>Используя поле <a class="el" href="struct_rsh_init_memory.html#a5d1d5e6e543365407f7de3ca71cc5fac" title="Размер предыстории ">RshInitMemory::preHistory</a> структуры инициализации, можно задать, какая часть буфера данных будет использована для записи данных "предыстории" (до события синхронизации) и "истории" (после события синхронизации).</p>
<dl class="section remark"><dt>Прим.</dt><dd>Параметр "предыстория" актуален только при работе в режиме синхронизации.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a0e6752acbff305759924b0ef0034f57b" title="Размер предыстории в отсчетах ">RSH_GET_DEVICE_PREHISTORY_SIZE</a> | <a class="el" href="page__synchronization.html">Синхронизация</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85"></a>RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает режим сбора данных с удвоенной частотой дискретизации. </p>
<p>Некоторые из высокочастотных устройств с собственной памятью могут работать в так называемом режиме <b>удвоения частоты</b>. Как правило, на таких устройствах установлено отдельное АЦП для оцифровки каждого канала. Когда устройство работает в обычном режиме, все АЦП работают параллельно, каждое цифрует данные со своего аналогового канала.<br/>
 В режиме удвоения частоты, 2 АЦП работают с данными <em>одного</em> аналогового канала (для большинства устройств это первый канал, для некоторых устройств можно задать канал, который будет использоваться для удвоения - см. <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0" title="Можно выбрать канал (каналы), который будут использоваться в режиме удвоения (учетверения) частоты...">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a>).<br/>
 В результате этого, частота дискретизации (и размер буфера) для этого канала удваивается, и если, к примеру, максимальная частота дискретизации для устройства 1ГГц, в режиме удвоения будет активен ТОЛЬКО один из двух каналов, но с частотой дискретизации 2ГГц. <br/>
 Пример:</p>
<div class="fragment"><div class="line"><a class="code" href="struct_i_rsh_device.html" title="Интерфейс используется для управления практически всеми АЦП/ЦАП устройствами ЗАО &quot;Руднев-Шиляев&quot;. ">IRshDevice</a>* device;</div>
<div class="line"></div>
<div class="line"><span class="comment">//получим допустимые размеры буфера для режима удвоения</span></div>
<div class="line"><a class="code" href="class_rsh_buffer_type.html" title="Шаблонный класс для конструирования буферов данных. ">RSH_BUFFER_U32</a> sizeList;</div>
<div class="line"><a class="code" href="_rsh_def_chk_8h.html#a811024d35b9b8a41095b1f583b649e56">U32</a> res = device-&gt;<a class="code" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">Get</a>(<a class="code" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a16d7bd1ab19a8278fdef1fe22ed1c1df" title="Список допустимых размеров буфера в режиме удвоения ">RSH_GET_DEVICE_SIZE_LIST_DOUBLE</a>, &amp;sizeList); </div>
<div class="line"><span class="keywordflow">if</span>(res != <a class="code" href="_rsh_consts___status_codes_8h.html#af5c23a07b5f7e111ef15a9aa32b4e261a76893786bb0b2da5cda7d5a42ba52972" title=": Ошибок нет. ">RSH_API_SUCCESS</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">//GET-код не поддерживается, это не страшно. Многие устройства не имеют специальных списков размеров для режима удвоения.</span></div>
<div class="line">    <span class="comment">// Просто получим стандартный список размеров, и умножим каждый размер на 2</span></div>
<div class="line">    res = device-&gt;<a class="code" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">Get</a>(<a class="code" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a84c7ab578a3e499a6ee1a06e4dc2168f" title="Список допустимых размеров блоков собираемых данных ">RSH_GET_DEVICE_SIZE_LIST</a>, &amp;sizeList); </div>
<div class="line">    <span class="keywordflow">if</span>(res != <a class="code" href="_rsh_consts___status_codes_8h.html#af5c23a07b5f7e111ef15a9aa32b4e261a76893786bb0b2da5cda7d5a42ba52972" title=": Ошибок нет. ">RSH_API_SUCCESS</a>)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//Обработка ошибки и выход</span></div>
<div class="line">        ...</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">//умножаем каждый размер в буфере на 2</span></div>
<div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> i=0; i&lt;sizeList.<a class="code" href="class_rsh_buffer_type.html#ab295a287ef7a1bde6b5732ef2cb6c97e" title="Количество элементов в буфере (актуальный размер). ">Size</a>(); ++i)</div>
<div class="line">        sizeList.<a class="code" href="class_rsh_buffer_type.html#a736f485e21c19f5f232e8fa061af4258" title="Указатель на выделнную для данных память. ">ptr</a>[i] *= 2;</div>
<div class="line">    </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//структура инициализации</span></div>
<div class="line"><a class="code" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> params;</div>
<div class="line"></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Частота дискретизации в Гц ">frequency</a> = 1e10+9; <span class="comment">//данный параметр игнорируется в режиме удвоения: сбор данных будет идти с максимально возможной частотой</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_memory.html#a5ee43a023c53caef1a1ee30665407085" title="Установка флага RshInitMemory::FreqDouble. ">SetFreqModeDouble</a>(); <span class="comment">//ставим флаг удвоения частоты</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Размер буфера в отсчетах ">bufferSize</a> = sizeList[0]; <span class="comment">//размер на канал. </span></div>
<div class="line"></div>
<div class="line"><span class="comment">//настройка каналов (допустим, устройство имеет два канала)</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">channels</a>[0].SetUsed();       <span class="comment">//этот канал будет использоваться для сбора данных в режиме удвоения</span></div>
<div class="line">params.<a class="code" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">channels</a>[1].SetUsed();       <span class="comment">// данный флаг будет проигнорирован, т.к. в режиме удвоения доступен только один канал</span></div>
</div><!-- fragment --><dl class="section remark"><dt>Прим.</dt><dd>Для составных устройств (многоканальных осциллографов), в которых используются 2 или более устройства в качестве базовых модулей, число каналов в режиме удвоения будет в два раза меньше, чеи общее число каналов осциллографа.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0" title="Можно выбрать канал (каналы), который будут использоваться в режиме удвоения (учетверения) частоты...">RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a29b7d124678551cd2ce885ce2857f12d"></a>RSH_CAPS_DEVICE_QUADRO_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает режим режим сбора данных с учетверенной частотой дискретизации. </p>
<p>Данный режим аналогичен удвоению частоты (<a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Устройство поддерживает режим сбора данных с удвоенной частотой дискретизации. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a>), единственное отличие - частота умножается на 4, а не на 2. Число каналов, соответственно, тоже делится на 4.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Устройство поддерживает режим сбора данных с удвоенной частотой дискретизации. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba"></a>RSH_CAPS_DEVICE_AUTO_CALIBRATION</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает режим автокалибровки. </p>
<p>Автоматическая внутренняя калибровка. Процедура калибровки индивидуальна для каждого устройства. Например, плата Леонардо II настраивает уровни смещения нуля при вызове метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром RSH_GET_DEVICE_AUTO_CALIBRATION_SET.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Флаг <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92" title="Библиотека абстракции содержит методы для проведения автоматической настройки и калибровки устройства...">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> не связан с этим флагом! Наличие <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92" title="Библиотека абстракции содержит методы для проведения автоматической настройки и калибровки устройства...">RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</a> говорит о том, что в библиотеке устройства присуствуют алгоритмы калибровки, нужные при настройке (предпродажной или ремонтной) устройства.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a39a86451f45417b3170a3f58efd563c7" title="Запуск процесса автоматической калибровки ">RSH_GET_DEVICE_AUTO_CALIBRATION_SET</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1d7c7830ca32b68ec713eaf7196502b6"></a>RSH_CAPS_DEVICE_SYNCHRO_INTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Аналоговые каналы устройства могут быть использованы в качестве источника синхронизации. </p>
<p>Используя структуру инициализации <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> можно задать порог срабатывания, условие перехода (фронт или спад), а также некоторые другие параметры и выбрать один из аналоговых входных каналов устройства в качестве источника синхронизации. После запуска процесса сбора данных с помощью метода <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Запуск процесса сбора данных или генерации сигнала. ">IRshDevice::Start()</a>, устройство будет ожидать прихода события синхронизации в соотвествии с заданными параметрами.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4e931de0e0a4fb97becc7c552239d2fd"></a>RSH_CAPS_DEVICE_SYNCHRO_EXTERNAL</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет дополнительный вход, который может быть использован в качестве источника синхронизации. </p>
<p>Параметры синхронизации (порог, условие перехода, использование фильтра и др.) могут быть заданы в структуре <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>. После запуска сбора данных с помощью метода <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Запуск процесса сбора данных или генерации сигнала. ">IRshDevice::Start()</a>, устройство будет ожидать прихода события синхронизаци в соотвествии с заданными параметрами.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Вход внешней синхронизации обычно отличается от аналоговых входов по своим параметрам. Он может иметь собственный входной диапазон, список коэффициентов усиления, переключение сопротивления входа, программируемые фильтры и т.д. Все эти параметры могут быть получены с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a>. Параметры, относящиеся к внешней синхронизации, имеют префикс <b>RSH_GET_DEVICE_EXT_SYNC</b>, например <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="Список допустимых коэффициентов усиления для входа внешней синхронизации ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a>.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a819d7c0f4299baf67e2c592b78340105"></a>RSH_CAPS_DEVICE_EXTERNAL_START</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает возможность внешнего запуска преобразования. </p>
<p>Процесс сбора данных может быть запущен подачей TTL сигнала на определенный цифровой вход устройства. Информация о подключении, уровне сигнала и условиях срабатывания содержится в руководстве пользователя для конкретного устройства.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Внешний запуск преобразования и внешняя синхронизация - не одно и то же! </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a842258001468451ee1fd6850b26e1581"></a>RSH_CAPS_DEVICE_HYSTERESIS</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет возможность задания уровня гистерезиса для синхронизации. </p>
<p>Некоторые устройства с аппаратной цифровой синхронизацией имеют возможность программно задавать уровень гистерезиса. <br/>
 Более подробно об этой фозможности смотрите тут: <a class="el" href="struct_rsh_init_memory.html#a87c7c94337fcefa2dbca2e84f603b88a" title="Гистерезис ">RshInitMemory::hysteresis</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html#a87c7c94337fcefa2dbca2e84f603b88a" title="Гистерезис ">RshInitMemory::hysteresis</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> | <a class="el" href="page__synchronization.html">Синхронизация</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a211335ed1c186623a20bbdd34ee5fb36"></a>RSH_CAPS_DEVICE_EXT_SYNC_GAIN_LIST</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет отдельный список коэффициентов усиления для входа внешней синхронизации. </p>
<p>Вход внешней синхронизации часто отличается от обычных аналоговых входов, и может иметь свой собственный список коэффициентов усиления. Получить этот список можно используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="Список допустимых коэффициентов усиления для входа внешней синхронизации ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Если вход внешней синхронизации поддерживает переключение входного сопротивления, можно получить два различных списка коэффициентов усиления для 50Ом и 1МОм режима, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с константами <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5abe43cede7b96f62a0a1198583f3b47de" title="Получение массива с коэффициентами усиления внешней синхронизации для входа 50Ом ">RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_50_OHM</a> и <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ae24bb732f8fa913c06d3b5b17050c29a" title="Получение массива с коэффициентами усиления внешней синхронизации для входа 1МОм ">RSH_GET_DEVICE_EXT_SYNC_GAIN_LIST_1_MOHM</a> соответственно.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> | <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a496a54d166138fae0b4e05ef7455d0ed" title="Список допустимых коэффициентов усиления для входа внешней синхронизации ">RSH_GET_DEVICE_EXT_SYNC_GAINLIST</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a42cb2fa30a80c290cf5c912a66001285"></a>RSH_CAPS_DEVICE_EXT_SYNC_FILTER_LOW</em>&nbsp;</td><td class="fielddoc">
<p>Фильтр низких частот может быть включен для входа внешней синхронизации. </p>
<p>Полоса пропускания, подавление и другие характеристики фильтра зависят от типа устройства, более подробная информация содержится в руководстве пользователя.<br/>
 Для управления каналом внешней синхронизации используется поле <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="Параметры входа внешней синхронизации ">RshInitMemory::channelSynchro</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>. Для того, чтобы задействовать ФНЧ, нужно выставить бит <a class="el" href="struct_rsh_synchro_channel.html#a06e3b68809075422733616aa8ed2c11fa8bb316fd68853752652e38d270fa5b7e" title="Включить фильтр низких частот для канала внешней синхронизации. ">RshSynchroChannel::FilterLow</a> в поле <a class="el" href="struct_rsh_synchro_channel.html#afbd53e5994cba96221bc05415838ca71" title="Дополнительные флаги ">RshSynchroChannel::control</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__r_u_8cpp-example.html">Пример настройки параметров входа внешней синхронизации</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6139d67568b35cfc2a7adde139fc1ec5"></a>RSH_CAPS_DEVICE_EXT_SYNC_FILTER_HIGH</em>&nbsp;</td><td class="fielddoc">
<p>Фильтр высоких частот может быть включен для входа внешней синхронизации. </p>
<p>Полоса пропускания, подавление и другие характеристики фильтра зависят от типа устройства, более подробная информация содержится в руководстве пользователя.<br/>
 Для управления каналом внешней синхронизации используется поле <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="Параметры входа внешней синхронизации ">RshInitMemory::channelSynchro</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>. Для того, чтобы задействовать ФВЧ, нужно выставить бит <a class="el" href="struct_rsh_synchro_channel.html#a06e3b68809075422733616aa8ed2c11face336eda8b6dc0a609b4d30fce8784d3" title="Включить фильтр высоких частот для канала внешней синхронизации ">RshSynchroChannel::FilterHigh</a> в поле <a class="el" href="struct_rsh_synchro_channel.html#afbd53e5994cba96221bc05415838ca71" title="Дополнительные флаги ">RshSynchroChannel::control</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__r_u_8cpp-example.html">Пример настройки параметров входа внешней синхронизации</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ae08ef0174287786460f481831ccea3a8"></a>RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM</em>&nbsp;</td><td class="fielddoc">
<p>Доступен режим входного сопротивления 50Ом для входа внешней синхронизации. </p>
<p>Если, кроме того, активен режим RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM, можно программно переключать входное сопротивление входа, используя поле <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="Параметры входа внешней синхронизации ">RshInitMemory::channelSynchro</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.<br/>
 Если 50Ом единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход внешней синхронизации всегда будет в единственном доступном состоянии.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056" title="Доступна возможность переключения состояния входа внешней синхронизации &quot;Открытый&quot;/&quot;Закрытый&quot;. ">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__r_u_8cpp-example.html">Пример настройки параметров входа внешней синхронизации</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7ac24ea80e3d47378983f78763e13318"></a>RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_1_MOHM</em>&nbsp;</td><td class="fielddoc">
<p>Доступен режим входного сопротивления 1МОм для входа внешней синхронизации. </p>
<p>Если, кроме того, активен режим RSH_CAPS_DEVICE_EXT_SYNC_INPUT_RESIST_50_OHM, можно программно переключать входное сопротивление входа, используя поле <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="Параметры входа внешней синхронизации ">RshInitMemory::channelSynchro</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.<br/>
 Если 1МОм единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход внешней синхронизации всегда будет в единственном доступном состоянии.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056" title="Доступна возможность переключения состояния входа внешней синхронизации &quot;Открытый&quot;/&quot;Закрытый&quot;. ">RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__r_u_8cpp-example.html">Пример настройки параметров входа внешней синхронизации</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9289a1ac611a5dd7fa3e17939ab95056"></a>RSH_CAPS_DEVICE_EXT_SYNC_COUPLING_AC_DC</em>&nbsp;</td><td class="fielddoc">
<p>Доступна возможность переключения состояния входа внешней синхронизации "Открытый"/"Закрытый". </p>
<p>Если синхровход работает в режиме входного сопротивления 1МОм, есть возможность задать состояние входа: открытый (постоянная составляющая сигнала учитывается) или закрытый (постоянная составляющая сигнала отбрасывается). Для установки параметра используется поле <a class="el" href="struct_rsh_init_memory.html#a9f2ee591064ded57426d8826ce4e8ae2" title="Параметры входа внешней синхронизации ">RshInitMemory::channelSynchro</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_synchro_channel.html" title="Параметры канала внешней синхронизации ">RshSynchroChannel</a> | <a class="el" href="_rsh_init_memroy_synchro_channel__r_u_8cpp-example.html">Пример настройки параметров входа внешней синхронизации</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a002451fcec1e06a5a45ef19cefc94a96"></a>RSH_CAPS_DEVICE_HAS_DAC_INSTALLED</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет один или несколько ЦАПов. </p>
<p>Управлять ЦАПами можно с помощью метода <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>, используя структуру инициализации <a class="el" href="struct_rsh_init_d_a_c.html" title="Структура для доступа к ЦАП. ">RshInitDAC</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Не путайте данную возможность с RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE. Для устройств, которые поддерживают RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE, генерация сигнала является основным предназначением.<br/>
 Например, устройства серии GSPF имеют внутренний буфер для данных, аттенюатор, возможность выдачи сигнала из внутреннего буфера с различной частотой дискретизации и в разных режимах - одиночный, с повторением, по внешнему триггеру.<br/>
 Флаг RSH_CAPS_SOFT_INIT_DAC говорит о том, что устройство может, помимо основной своей задачи (сбор и оцифровка данных), выдать сигнал на ЦАП, причем никаких других действий кроме установки заданного уровня сигнала на выходе произвести нельзя.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b" title="Структура инициализации RshInitDAC поддерживается библиотекой абстракции. ">RSH_CAPS_SOFT_INIT_DAC</a> | <a class="el" href="struct_rsh_init_d_a_c.html" title="Структура для доступа к ЦАП. ">RshInitDAC</a> | <a class="el" href="_rsh_init_d_a_c__r_u_8cpp-example.html">пример управления ЦАПом</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abf6f85bf5eab39826a654553549b2316"></a>RSH_CAPS_DEVICE_INPUT_LEVEL_ADJUSTMENT</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет возможность подстройки уровня входного напряжения аналоговых каналов. </p>
<p>Обычно, диапазон подстройки уровня входного напряжения совпадает со входным диапазоном канала. Управлять этим параметром можно отдельно для каждого канала в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitADC::channels</a>, используя поле <a class="el" href="struct_rsh_channel.html#a4d439cfb01993d1b6a9bada675f3f5bd" title="Подстройка уровня входного напряжения ">RshChannel::adjustment</a>.<br/>
 Допустим, канал имеет входной диапазон ±25В, а на входе синусоидальный сигнал со средним значениме 20В и амплитудой 10В. Без коррекции входного напряжения на входе АЦП будет сигнал от 35В до 10В, и оцифровать его без потерь не получится. Установив же параметр <a class="el" href="struct_rsh_channel.html#a4d439cfb01993d1b6a9bada675f3f5bd" title="Подстройка уровня входного напряжения ">RshChannel::adjustment</a> равным, к примеру, -15В, мы получим на входе АЦП сигнал в диапазоне от 35-15=20В до 10-15=-5В, который может быть оцифрован без потерь.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Добиться похожего результата можно, используя режим <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ae07c02266bb6316aef1e935eb085b169" title="Установить состояние входа &quot;закрытый&quot;. ">RshChannel::AC</a>, если флаг <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="Доступна возможность переключения состояния аналоговых входов &quot;открытый/закрытый&quot;. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> доступен для устройства.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> | <a class="el" href="struct_rsh_init_a_d_c.html" title="Базовая структура инициализации для АЦП устройств ">RshInitADC</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d"></a>RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</em>&nbsp;</td><td class="fielddoc">
<p>Доступна возможность переключения состояния аналоговых входов "открытый/закрытый". </p>
<p>Если аналоговый канал поддерживает входное сопротивление 1МОм, в этом режиме можно переключать состояние канала между "открытый вход" и "закрытый вход", устанавливая один из флагов (<a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ae07c02266bb6316aef1e935eb085b169" title="Установить состояние входа &quot;закрытый&quot;. ">RshChannel::AC</a> или <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769a0697a87cd110fb1efc9f2f7d379d659c" title="Установить состояние входа &quot;открытый&quot;. ">RshChannel::DC</a>) в поле <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Дополнительные флаги ">RshChannel::control</a> для выбранного канала в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitMemory::channels</a> в структуре инициализации <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> | <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="_rsh_channel_setup__r_u_8cpp-example.html">Пример настройки каналов</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8ef713b84c323d70257b352ec1370075"></a>RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM</em>&nbsp;</td><td class="fielddoc">
<p>Доступен режим входного сопротивления 50Ом для аналоговых каналов. </p>
<p>Если, кроме того, активен режим RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM, можно программно переключать входное сопротивление входа, используя поле <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Дополнительные флаги ">RshChannel::control</a> для выбранного канала в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitMemory::channels</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.<br/>
 Если 50Ом единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход всегда будет в единственном доступном состоянии.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="Доступна возможность переключения состояния аналоговых входов &quot;открытый/закрытый&quot;. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> | <a class="el" href="_rsh_channel_setup__r_u_8cpp-example.html">Пример настройки каналов</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a06104c4dec442b75afaa51ed1f5dbdde"></a>RSH_CAPS_DEVICE_INPUT_RESIST_1_MOHM</em>&nbsp;</td><td class="fielddoc">
<p>Доступен режим входного сопротивления 1МОм для аналоговых каналов. </p>
<p>Если, кроме того, активен режим RSH_CAPS_DEVICE_INPUT_RESIST_50_OHM, можно программно переключать входное сопротивление входа, используя поле <a class="el" href="struct_rsh_channel.html#a6f05939a8bdf152a70e5fd9393a980c9" title="Дополнительные флаги ">RshChannel::control</a> для выбранного канала в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitMemory::channels</a> структуры <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.<br/>
 Если 1МОм единственная доступная опция, или вообще ни одна из опций неактивна, использование данной настройки не будет иметь эффекта, и вход всегда будет в единственном доступном состоянии.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При переключении сопротивления входа нужно помнить, что списки коэффициентов усиления различаются для разных входных сопротивлений. Кроме того, некоторые опции (например, возможность использования открытого/закрытого входа) доступны только в режиме 1МОм входа.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a84cb07c137f1a07591610e905e1b441d" title="Доступна возможность переключения состояния аналоговых входов &quot;открытый/закрытый&quot;. ">RSH_CAPS_DEVICE_INPUT_COUPLING_AC_DC</a> | <a class="el" href="struct_rsh_channel.html" title="Параметры аналогового канала ">RshChannel</a> | <a class="el" href="_rsh_channel_setup__r_u_8cpp-example.html">Пример настройки каналов</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866afe2bb60b36d6727f6c772154b53487c0"></a>RSH_CAPS_DEVICE_FRAME_FREQUENCY_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает режим кадрового сбора. </p>
<p>В этом режиме задаются две частоты:<br/>
 одна определяет частоту внутри кадра (интервал между данными с разных каналов), а другая - частоту кадров (интервал между блоками данных, в каждом блоке - по одному отсчету с каждого выбранного для измерения канала).<br/>
 Этот режим полезен при использовании устройства АЦП, каналы которого мультиплексируются (не являются синхронными), с низкой частотой дискретизации. Без включения кадрового режима при использовании низкой частоты дискретизации интервал между каналами будет очень большим. Но если включить данный режим, можно одновнременно получить низкую частоту дискретизации и маленький интервал между измерениями с разных каналов.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> | <a class="el" href="page__frame_freq_mode.html">Кадровый режим сбора данных</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9b0777dfe1f4aae1634e1b93227005d0"></a>RSH_CAPS_DEVICE_PACKET_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает пакетный режим сбора данных. </p>
<p>Этот режим используется для устройств сбора данных с установленной собственной памятью. Такие устройства собирают данные во внутренний буфер (размер которого может составлять несколько мегабайт), а затем передают эти данные в компьютер по относительном медленным интерфейсам (USB, PCI). Если задан небольшой размер буфера для сбора, основное время уходит не на сбор данных, а на инициализацию сбора и передачу их в компьютер.<br/>
</p>
<p>Пакетный режим, таким образом, может быть очень полезен: в этом режиме можно задать размер блока данных( поле <a class="el" href="struct_rsh_init_a_d_c.html#a9169154ef3e721aa8eaa72a1df3f3451" title="Размер буфера в отсчетах ">RshInitMemory::bufferSize</a>) и количество этих блоков (поле <a class="el" href="struct_rsh_init_memory.html#a3543ce04d314091390cd636baf8723d6" title="Количество пакетов ">RshInitMemory::packetNumber</a>). Очевидно, что итоговый размер, равный <b>bufferSize*packetNumber</b>, должен быть меньше, чем максимальный объем доступной внутренней памяти <b>MaximumMemory</b> (его можно узнать с помощью метода <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a82758a9373af6e92b9606633d83a2c67" title="Размер памяти, установленной на плате (или доступной для сбора) ">RSH_GET_DEVICE_MEMORY_SIZE</a>).<br/>
 Когда будет запущен процесс сбора данных с помощью метода <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Запуск процесса сбора данных или генерации сигнала. ">IRshDevice::Start()</a>, устройство будет собирать данные (используя все заданные параметры сбора, настройки синхронизации и т.д.) до тех пор, пока не соберет <a class="el" href="struct_rsh_init_memory.html#a3543ce04d314091390cd636baf8723d6" title="Количество пакетов ">RshInitMemory::packetNumber</a> блоков данных. Только после этого начнется передача данных в компьютер. <br/>
 Таким образом, можно, например, записать без пропусков несколько быстрых процессов, идущих с небольшим интервалом, что было бы невозможно в обычном режиме.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a72bc3e5be326765db46df01f989d8901"></a>RSH_CAPS_DEVICE_START_DELAY</em>&nbsp;</td><td class="fielddoc">
<p>Сбор данных может быть начат с задержкой (относительно события синхронизации) </p>
<p>Если устройство работает в режиме ожидания события синхронизации, можно задать интервал времени (поле <a class="el" href="struct_rsh_init_memory.html#aea66679c9372b4e0fa831ea3db5b19c7" title="Задержка старта ">RshInitMemory::startDelay</a>), определяющий задержку старта. Когда будет получено событие синхронизации, запись данных в буфер начнется не мгновенно, а через заданное в поле <b>startDelay</b> время. <br/>
 Эта опция, по сути, "предыстория наоборот" (предыстория задается в поле <a class="el" href="struct_rsh_init_memory.html#a5d1d5e6e543365407f7de3ca71cc5fac" title="Размер предыстории ">RshInitMemory::preHistory</a>).</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="page__synchronization.html">Синхронизация</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aab020fd08c44e6af6b9ff1ca657e59f5"></a>RSH_CAPS_DEVICE_SLAVE_MASTER_SWITCH</em>&nbsp;</td><td class="fielddoc">
<p>Сбор данных может быть запущен от ведущего устройства. </p>
<p>Задав <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaae840f4e9feb73bd6ea90b452c898b977" title="Запуск от ведущего устройства ">RshInitADC::Master</a> в качестве источника запуска в поле <a class="el" href="struct_rsh_init_a_d_c.html#a3efbcf323a21adb0ba6de43ed3b5871f" title="Режим запуска сбора данных ">RshInitADC::startType</a>, можно сделать устройство "ведомым" (slave). После вызова метода <a class="el" href="struct_i_rsh_device.html#a47d6a77d7311d54deea8c02ad77e66fc" title="Запуск процесса сбора данных или генерации сигнала. ">IRshDevice::Start()</a>, устройство будет находиться в режиме ожидания (как при использовании синхронизации), и сбор данных начнется только при получении специального сигнала от ведущего (Master) устройства</p>
<dl class="section remark"><dt>Прим.</dt><dd>Даная возможность чаще всего применяется в составных системах, где несколько одинаковых устройств используются для синхронного сбора данных. Необходимо соединять ведущее и ведомое (или ведомые) устройства специальным кабелем, чтобы система заработала в таком режиме. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ae0218b6df2f5e3cef65793b25a48389a"></a>RSH_CAPS_DEVICE_SYNCHRO_CHANNELS</em>&nbsp;</td><td class="fielddoc">
<p>Аналоговые каналы устройства - синхронные. </p>
<p>Если данный флаг активен, устройство имеет свой собственный АЦП на каждом из аналоговых каналов, все эти АЦП тактируются из одного источника, и данные со всех каналов собираются синхронно.<br/>
 Если же верно обратное, устройство имеет только один АЦП и аналоговые каналы оцифровываются по очереди (мультиплексируются). При этом все отсчеты отделены друг от друга по времени на величину 1/F, где F - частота дискретизации.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Если устройство не поддерживает данную опцию (каналы не синхронны), максимальная частота дискретизации всегда делится на количество активных (участвующих в сборе данных) каналов. Например, если максимальная частота дискретизации устройства составляет 500кГц, при использовании двух каналов максимально возможное значение частоты в поле <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Частота дискретизации в Гц ">RshInitADC::frequency</a> будет равно 250кГц.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_a_d_c.html" title="Базовая структура инициализации для АЦП устройств ">RshInitADC</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a9f291ff9cb8c78e6cc63fe9dd7732001"></a>RSH_CAPS_DEVICE_EXTERNAL_FREQUENCY</em>&nbsp;</td><td class="fielddoc">
<p>АЦП может тактироваться из внешнего источника. </p>
<p>Чтобы включить эту возможность, нужно установить бит <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaa77f738f46a81db5a1dff418cab5c78f7" title="Использование внешней частоты дискретизации ">RshInitADC::FrequencyExternal</a> в поле <a class="el" href="struct_rsh_init_a_d_c.html#a3efbcf323a21adb0ba6de43ed3b5871f" title="Режим запуска сбора данных ">RshInitADC::startType</a> структуры инициализации. Можно комбинировать этот режим (используя логическое ИЛИ) с другими флагами, например <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaa9db2e34cceb99c7fe481cfa58a7a3cb3" title="Запуск по таймеру ">RshInitADC::Timer</a>, <a class="el" href="struct_rsh_init_a_d_c.html#a052804ec71ccbe925a8b33359bd233eaaa85aaa4fbccb5d9ef642002a37203c98" title="Внутренняя синхронизация ">RshInitADC::Internal</a>.<br/>
 Требования к сигналу (амплитуда, скважность, полярность и пр.) описаны в руководстве пользователя для каждого конкретного устройства.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При использовании данной возможности, поле <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Частота дискретизации в Гц ">RshInitADC::frequency</a> структуры инициализации все еще актуально (по крайней мере, для большинства устройств), т.к. заданная в нем частота используется для вычисления значения делителя частоты.<br/>
 Например, если максимальная частота дискретизации устройства составляет 500кГц, в качестве внешней тактовой частоты используется сигнал с частотой 150кГц, а в поле <a class="el" href="struct_rsh_init_a_d_c.html#a2f51fdaa389ac6d8fdaa704305df298a" title="Частота дискретизации в Гц ">RshInitADC::frequency</a> задана частота 250кГц, при оцифровке будет использовано значение делителя частоты равное 500/250 = 2. Таким образом, получим, что реальная частота дискретизации будет равна 150/2 = 75кГц. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866abbd6a3d6733d7e318c076e5dc28c23f1"></a>RSH_CAPS_DEVICE_FREQUENCY_SWITCH_PREHISTORY</em>&nbsp;</td><td class="fielddoc">
<p>Доступна возможность переключения частоты дискретизации после получения события синхронизации. </p>
<p>Если доступна данная возможность, можно использовать две разные частоты для "предыстории" и "истории" данных в буфере. Частота предыстории задается как обычно (поле <b>frequency</b> структуры инициализации), а частота истории может быть переключена либо на максимальную для данного устройства частоту (Fmax), либо на частоту Fmax/8.<br/>
 Включить этот режим работы можно, используя флаги <a class="el" href="struct_rsh_init_a_d_c.html#ae62d171ab48740511a0571263a9e3939aec69366ab34f2397535633973ed45fdc" title="Предыстория и история собираются с разными частотами (переключение на низкую частоту) ...">RshInitMemory::FrequencySwitchToMinimum</a> и <a class="el" href="struct_rsh_init_a_d_c.html#ae62d171ab48740511a0571263a9e3939ae967f9ca6620011f8f83ff414c92ac47" title="Предыстория и история собираются с разными частотами (переключение на высокую частоту) ...">RshInitMemory::FrequencySwitchToMaximum</a> в поле <a class="el" href="struct_rsh_init_a_d_c.html#acbd0e3074cc4af0a7228093bd81b9161" title="Дополнительные параметры синхронизации ">RshInitMemory::controlSynchro</a> структуры инициализации <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a6c7150b861a56ded470fb3f7742ea21b" title="Доступна возможность записи предыстории измерения. ">RSH_CAPS_DEVICE_PREHISTORY</a> | <a class="el" href="page__synchronization.html">Синхронизация</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a52cee3b9bd2582c0cfd4cdc1827031c0"></a>RSH_CAPS_DEVICE_FREE_CHANNEL_SELECT_IN_EXT_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Можно выбрать канал (каналы), который будут использоваться в режиме удвоения (учетверения) частоты. </p>
<p>Если доступна данная возможность, можно указать, какой канал (или каналы) будет использоваться в режиме удвоения частоты. По умолчанию, всегда используется нулевой канал (или четные каналы, если их количество больше двух). Выбор каналов осуществляется с помощью стандартного флага <a class="el" href="struct_rsh_channel.html#a0770ebc6c5151c5c36d8c1335c19b769ab1f9ac172ca4a0c1bb0fd95585e3bd6f" title="Канал будет использоваться при сборе данных ">RshChannel::Used</a> в списке <a class="el" href="struct_rsh_init_a_d_c.html#aeb89a28e7e1a808330a4fda0ef19cec9" title="Настройки аналоговых каналов ">RshInitMemory::channels</a> структуры инициализации.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная возможность также актуальна и для режима учетверения, за исключением того, что можно выбрать один канал из каждых четырех, а не два, как в режиме удвоения.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866a4cd30563ed3d8eb44a883ad50df12b85" title="Устройство поддерживает режим сбора данных с удвоенной частотой дискретизации. ">RSH_CAPS_DEVICE_DOUBLE_FREQUENCY_MODE</a> | <a class="el" href="_i_rsh_device__double_freq_mode__r_u_8cpp-example.html">Пример задания параметров</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a1ea35492c22a13ec7ed1d04bb46b19b1"></a>RSH_CAPS_DEVICE_DIFFERENTIAL_INPUT_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Доступна возможность программно переключаться между однополюсным/дифференциальным режимом. </p>
<p>По умолчанию, устроства работают в однополюсном режиме. Чтобы задействовать дифференциальный режим работы, нужно установить флаг <a class="el" href="struct_rsh_init_d_m_a.html#ad85b05bbb1e37cffbefce3c074a9aa02a8ab8ed214bc57f8c4b30d3acbb84bcb1" title="Включение дифференциального режима работы ">RshInitDMA::DiffMode</a> в поле <a class="el" href="struct_rsh_init_d_m_a.html#a2ab1a6e058c24c69aa320d0d8b0e9633" title="Дополнительные опции ">RshInitDMA::control</a> структуры инициализации.</p>
<dl class="section remark"><dt>Прим.</dt><dd>При включении дифференциального режима количество каналов становится меньше в два раза, так как оцифровывается разностное напряжение двух входов. Кроме того, требуется выполнить подключение сигналов в соответствии со схемой подключения дифференциальных входов согласно руководству пользователя.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a729f46ef82a336136a8d9c2b2ff4864c"></a>RSH_CAPS_DEVICE_FLASH_INFO_ONBOARD</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет энергонезависимую память (флэш), которая содержит дополнительную информацию. </p>
<p>Наличие данного флага означает, что устройство располагает дополнительной памятью, в которую может быть записан заводской номер платы, различные настроечные коэффициенты и другая информация. Как правило, информация записывается на этапе настройки и в процессе эксплуатации доступна только для чтения. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866adc0c2c58e598217f009c8da5d6a32355"></a>RSH_CAPS_DEVICE_GPS_MODULE_INSTALLED</em>&nbsp;</td><td class="fielddoc">
<p>Устройство имеет GPS-модуль </p>
<p>Получить данные GPS можно, вызвав метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a358aa4d0b4c731a0768cee1368095125" title="Получение данных GPS. ">RSH_GET_DEVICE_GPS_DATA</a> или <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5ae56834ed5210a3985bcb58aa5b75d1e8" title="Получение данных GPS (Unicode) ">RSH_GET_DEVICE_GPS_DATA_UTF16</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Формат строки с данными зависит от устройства и используемого модуля, все подробности приведены в описании устройства. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4a5a6e1eaea445c32aa1e7b859f79547"></a>RSH_CAPS_DEVICE_AUTO_START_MODE</em>&nbsp;</td><td class="fielddoc">
<p>Устройство поддерживает режим автоматического запуска </p>
<p>Устройство может быть запрограммировано таким образом, что сбор данных будет запускаться автоматически, с заданным интервалом. Интервал запуска можно задать, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5a503bd52901c5f2996212c757abe61564" title="Установка интервала автозапуска ">RSH_GET_DEVICE_AUTO_START_INTERVAL_SET</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данный режим работы - это <b>НЕ</b> непрерывный режим. Каждый блок данных, получаемый от устройства, независим и не связан с предыдущим. Единственное отличие от стандартного режима "Старт-Стоп" в том, что не нужно запускать сбор каждый раз - устройство будет делать это автоматически.<br/>
 С программной точки зрения, однако, процесс работы с устройством выглядит очень похожим на работу в непрерывном режиме - нужно задать параметры сбора данных (в том числе и интервал опроса), запустить сбор и затем получать данные длительное время, ожидая событие готовности для каждого собранного буфера. Процесс сбора данных может быть остановлен вызовом метода <a class="el" href="struct_i_rsh_device.html#a58ed2025368f7aabe6db1ac49b56b553" title="Остановка процесса сбора данных или генерации сигнала. ">IRshDevice::Stop()</a>. </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ac2dd322d1bd59b2cfd167b88f55baff0"></a>RSH_CAPS_DEVICE_DIGITAL_PORT_DATA_WITH_ANALOG_DATA</em>&nbsp;</td><td class="fielddoc">
<p>Цифровые данные могут передаваться вместе с аналоговыми. </p>
<p>Устройство имеет возможность получать данные со своего цифрового порта или входных цифровых линий вместе с аналоговыми данными. Цифровые данные помещаются в несколько младших битов каждого слова данных.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Используется специальный флаг ( <a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="Передача состояния входных линий цифрового порта вместе с данными. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a>) при вызове метода <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Получение (или отправка) буфера с данными. ">IRshDevice::GetData()</a> для того, чтобы цифровые данные не были отмаскированы. См. <a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="Передача состояния входных линий цифрового порта вместе с данными. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a> для более подробного описания.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="_rsh_consts___get_data_modes_8h.html#aa66f31cd5fa19e26cdb77dee428ac536ae76e61b6770abc72b0ec6ed288eb4b35" title="Передача состояния входных линий цифрового порта вместе с данными. ">RSH_DATA_MODE_CONTAIN_DIGITAL_INPUT</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a8bba91728660b6f130a6ba47bf1fdf92"></a>RSH_CAPS_SOFT_CALIBRATION_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для проведения автоматической настройки и калибровки устройства. </p>
<p>Наличие данного флага означает, что устройство может быть откалибровано (настройка внутренних коэффициентов) программно, с использованием внешнего источника сигнала и эталонного измерительного прибора.<br/>
 Данная возможность не связана с наличием флага <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866af6160ae2b5913ce61a81ccbe0a98c3ba" title="Устройство поддерживает режим автокалибровки. ">RSH_CAPS_DEVICE_AUTO_CALIBRATION</a> (автоматическая подстройка нуля в процессе работы). Режим автоматической калибровки используется только при производстве и ремонте устройств. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aefaad7f3baecfb66eeff2f68be7e0a9d"></a>RSH_CAPS_SOFT_GATHERING_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для осуществления сбора данных в режиме "старт-стоп". </p>
<p>Устройство может быть запрограммировано для сбора данных в режиме "Старт-Стоп". В этом режиме происходит одиночный запуск устройства, сбор одного блока данных с заданными параметрами (частота дискретизации, размер и т.д.) и остановка устройства. Этот сценарий работы является наибоелее распространенным.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> | <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866acfd92070f34276c75c9cef5f486fb246"></a>RSH_CAPS_SOFT_PGATHERING_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для осуществления сбора данных в непрерывном режиме </p>
<p>В этом режиме АЦП запускается один раз, и затем оцифровывает входные сигналы непрерывно, генерируя прерывание каждый раз, когда готова очередная порция данных. Этот процесс может продолжаться долгое время (теоретически, бесконечно) и будет остановлен только при вызове метода <a class="el" href="struct_i_rsh_device.html#a58ed2025368f7aabe6db1ac49b56b553" title="Остановка процесса сбора данных или генерации сигнала. ">IRshDevice::Stop()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Из-за аппаратных ограничений по пропускной способности различных интерфейсов, этот режим доступен только для относительно низкочастотных устройств (до 10МГц).</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866ad726d65aed23416c15896fde9429c91e"></a>RSH_CAPS_SOFT_DIGITAL_PORT_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для управления цифровым портом. </p>
<p>Используя метод <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> и структуру инициализации <a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> можно читать и записывать данные в цифровой порт устройства. Получить информацию о цифровом порте можно, используя метод <a class="el" href="struct_i_rsh_device.html#a8afa4c54b4302eca2d5827fe9d9c1468" title="Получение различной информации об устройстве и библиотеке абстракции. ">IRshDevice::Get()</a> с параметром <a class="el" href="_rsh_consts___get_codes_8h.html#a89a326bf9f936379d19de8e46e4c56d5afe60859b2477277000383fa798df592d" title="Получeние структуры из со служебной информацией о портах ">RSH_GET_DEVICE_PORT_INFO</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> | <a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> | <a class="el" href="struct_rsh_port_info.html" title="Информация о цифровом порте ">RshPortInfo</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a32c747c421e618cb1140269dace49079"></a>RSH_CAPS_SOFT_GENERATION_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для генерации сигнала. </p>
<p>Используя структуру инициализации <a class="el" href="struct_rsh_init_g_s_p_f.html" title="Cтруктура инициализации для генераторов ">RshInitGSPF</a> можно задать параметры генерации сигнала, и затем отправить сформированный буфер данных с сигналом в устройство, используя метод <a class="el" href="struct_i_rsh_device.html#a5fe82265d052163e34a1ffab4fec1c6d" title="Получение (или отправка) буфера с данными. ">IRshDevice::GetData()</a>.</p>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_g_s_p_f.html" title="Cтруктура инициализации для генераторов ">RshInitGSPF</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a5ed5faedf3212a6c617025124db414ce"></a>RSH_CAPS_SOFT_INIT_MEMORY</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура обычно используется для высокочастотных устройств сбора данных с установленной собственной памятью.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_memory.html" title="Структура инициализации для устройств типа &quot;Memory&quot;. ">RshInitMemory</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a6b5450990b92306f3c288cd8325be52c"></a>RSH_CAPS_SOFT_INIT_DMA</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура обычно используется для низкочастотных устройств сбора данных. Используя эту структуру, можно организовать сбор данных в непрерывном режиме.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_m_a.html" title="Структура инициализации для устройств типа &quot;DMA&quot;. ">RshInitDMA</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866adefc92cd8599903fa80aa6a5b100b837"></a>RSH_CAPS_SOFT_INIT_GSPF</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_g_s_p_f.html" title="Cтруктура инициализации для генераторов ">RshInitGSPF</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура используется для программирования устройств серии ГСПФ.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_g_s_p_f.html" title="Cтруктура инициализации для генераторов ">RshInitGSPF</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a91e93fec1d767db707c24a2d9893d634"></a>RSH_CAPS_SOFT_INIT_VOLTMETER</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_voltmeter.html" title="Cтруктура инициализации для вольтметров типа B7-78. ">RshInitVoltmeter</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура используется для программирования цифровых вольтметров с интерфейсом VISA.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_voltmeter.html" title="Cтруктура инициализации для вольтметров типа B7-78. ">RshInitVoltmeter</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866aa3e2fe9f73f6764cf89f870e782a1d74"></a>RSH_CAPS_SOFT_INIT_TIMER</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_timer.html" title="Прямое управление таймерами ">RshInitTimer</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура используется для прямого управления программируемым счетчиком-таймером устройства.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_timer.html" title="Прямое управление таймерами ">RshInitTimer</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> | <a class="el" href="_rsh_consts___caps_codes_8h.html#a7d002d179754641063bf0db5344f5866abd0ffb417d83716e2094027a20a4a7df" title="В устройстве установлен программируемый счетчик-таймер Intel 8254. ">RSH_CAPS_DEVICE_TIMER_8254</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a12ec3905812e467bfcb3be66da310ec8"></a>RSH_CAPS_SOFT_STROBOSCOPE</em>&nbsp;</td><td class="fielddoc">
<p>Библиотека абстракции содержит методы для реализация программного стробоскопа. </p>
<p>Стробоскопирование работает только для периодических сигналов, и при включенной синхронизации. Получая информацию о точном моменте срабатывания синхронизации, можно из нескольких реализации периодического сигнала построить одну, но с более высоким временным разрешением. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a7c64477dd605fa74b9c0d8c0c693b38b"></a>RSH_CAPS_SOFT_INIT_DAC</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_d_a_c.html" title="Структура для доступа к ЦАП. ">RshInitDAC</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура используется для управления ЦАПами.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_d_a_c.html" title="Структура для доступа к ЦАП. ">RshInitDAC</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a64b485141c3711ba52383ba4990f3620"></a>RSH_CAPS_SOFT_INIT_PORT</em>&nbsp;</td><td class="fielddoc">
<p>Структура инициализации <a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> поддерживается библиотекой абстракции. </p>
<p>Использовать эту структуру для передачи параметров можно в методе <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a>.</p>
<dl class="section remark"><dt>Прим.</dt><dd>Данная структура используется для управления цифровым портом.</dd></dl>
<dl class="section see"><dt>См. также</dt><dd><a class="el" href="struct_rsh_init_port.html" title="Операции с цифровым портом ">RshInitPort</a> | <a class="el" href="struct_i_rsh_device.html#a4706cd2760eb548240eeb8f49041f964" title="Установка параметров сбора и настройка устройства. ">IRshDevice::Init()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a4013f7fb7ad5fa0e49b5b1a950daec30"></a>RSH_CAPS_SOFT_TUNER_MODE_IS_AVAILABLE</em>&nbsp;</td><td class="fielddoc">
<p>Внутренние настройки устройства могут быть изменены с использованием данной библиотеки абстракции. </p>
<p>Для изменения значений внутренних настроечных коэффициентов устройства используется специальный набор методов и структур, которые являются закрытыми. Тюнер используется только при первоначальной настройке и предпродажной подготовке устройства. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7d002d179754641063bf0db5344f5866a74a0c31f5093f34767ed96ba1f48c0b7"></a>RSH_CAPS_MAX</em>&nbsp;</td><td class="fielddoc">
<p>Максимальное количество значений в перечислении RSH_CAPS. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Документация по Rsh API. Последние изменения: Ср 30 Дек 2015 12:21:32. Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
</small></address>
</body>
</html>
